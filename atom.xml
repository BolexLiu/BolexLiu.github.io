<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我是一只香脆的大鸡排</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.dajipai.cc/"/>
  <updated>2018-12-18T15:38:36.301Z</updated>
  <id>http://www.dajipai.cc/</id>
  
  <author>
    <name>香脆的大鸡排</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android-fd（文件描述符）</title>
    <link href="http://www.dajipai.cc/archives/377638cf.html"/>
    <id>http://www.dajipai.cc/archives/377638cf.html</id>
    <published>2018-12-18T13:19:22.000Z</published>
    <updated>2018-12-18T15:38:36.301Z</updated>
    
    <content type="html"><![CDATA[<p>进程中android中io、socket、thread对于操作系统是什么？最多能创建多少个？</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年工作中发现应用跑了很长一段时间后，突然：</p><ul><li>数据库打不开</li><li>sharedpreferences无法读取</li><li>网络无法连接</li><li>文件不可读写</li></ul><p>总之就是一切涉及IO的操作都不能做。其中找了很多办法来试图解决这个问题，都是不痛不痒的无法定位到问题所在。如追溯日志、debug立即调试均无异常。</p><p>最终在使用多机型和不同的android版本上复现了。复现的步骤比较粗暴，就是把网络断掉。然后让程序跑一会儿。也是后面才发现可以这样复现，之前每次要跑十几个小时才会出一次这样的问题。还是非必现的。</p><p>一般的应用也许很难碰到这样的场景，我先讲一个前置条件。</p><ul><li>频繁创建socket</li><li>频繁的IO读写</li><li>频繁的线程创建和关闭</li></ul><p>先简单说一下这个问题的产生原因和解决办法，后面我们再从中分析原理。</p><p>应用具备了和服务端保持长链接的能力，保持实时push数据给服务器，由于我们做了重连机制，最后发现在弱网环境下由于消息无法送达socket会重复的断开和重连服务器。又因为使用socket是在java层写的<code>close()</code>并非真实关闭释放，android虚拟机在4.4以后的版本在某些场景下就有可能无法成功释放linux层fd。导致每重连一次fd就会+1。最终会因为fd达到了linux默认值上限后而无法创建导致android层看不到异常也无法正常使用IO相关的api工作。</p><p>解决的办法就是优化重连机制，把socket下沉到native去维护。java不要在干这件事了。</p><h2 id="fd是什么"><a href="#fd是什么" class="headerlink" title="fd是什么"></a>fd是什么</h2><p><strong>fd（file descriptor）</strong>：</p><p>直译就是文件描述符，它表示当前打开的文件索引。不管我们是创建socket、io、线程最终对应到linux底层都是文件描述符的形式,相信对linux有认识的同学都听说过一句话叫：“Linux下，一切皆文件”。在这个平台上其实不管我们做的什么操作，最终都对应成了文件。我们看一下维基百科怎么说的吧。</p><p><strong><a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6" target="_blank" rel="noopener">维基百科</a></strong></p><blockquote><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p></blockquote><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>如果你现在手上有一台root过的android设备，可以通过shell到/proc/{PID}/fd目录下使用查看当前应用的文件描述符数量。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line">cd /proc/&#123;PID&#125;/fd</span><br><span class="line">ls | wc -w</span><br></pre></td></tr></table></figure></p><p>其中PID是进程id。去年验证该问题的时候我采用了观察断网前后来排查该错误，以下是当时的笔记部分：</p><ul><li>断网前：95左右跳动（这里的跳动是正常close）</li><li>断网后：从95自增飙升到一千多随后开始IO不可用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br><span class="line">lr-x------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 72 -&gt; /system/app/webview/webview.apk</span><br><span class="line">lr-x------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 73 -&gt; /dev/urandom</span><br><span class="line">lrwx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 74 -&gt; anon_inode:[eventpoll]</span><br><span class="line">lrwx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 75 -&gt; socket:[13214]</span><br><span class="line">lrwx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 76 -&gt; socket:[13215]</span><br><span class="line">lr-x------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 77 -&gt; pipe:[13216]</span><br><span class="line">l-wx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 78 -&gt; pipe:[13216]</span><br><span class="line">lrwx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 79 -&gt; anon_inode:[eventpoll]</span><br><span class="line">lrwx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 8 -&gt; /dev/binder</span><br><span class="line">lrwx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 80 -&gt; socket:[13218]</span><br><span class="line">lrwx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 81 -&gt; socket:[13219]</span><br><span class="line">lrwx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 82 -&gt; /dev/ashmem</span><br><span class="line">lr-x------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 83 -&gt; pipe:[13220]</span><br><span class="line">l-wx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 84 -&gt; pipe:[13220]</span><br><span class="line">lrwx------ 1 u0_a52 u0_a52 64 2017-06-07 10:33 85 -&gt; socket:[17045]</span><br></pre></td></tr></table></figure><p>可以看到有pipe和socket，这里的pipe是Linux进程通信管道。暂时不去管它。socket的数目明显不对。断网重连网络，再到释放网络。这里的释放根本不起作用。虽然java调用了close方法。但是在fd里的描述符仍然被持续占用。到占满后就导致不允许再创建任何文件描述符。</p><p>带着这样的疑问，我又尝试在4.4和6.0的android版本中做测试，发现在android4.4中会释放。到android 6.0却不会释放。由于真设备是从4.4升级到了6.0在当初开发这个模块的时候问题并没有暴露出来。而换了6.0以后也需要再非常极端的网络不稳定和数个小时候才能复现。问题迟迟被拖了这么久没有被解决。</p><p>从用户反馈的角度来看就是设备（应用）死机了。表象上去看没有任何错误日志，实际是日志系统并没有记录下来，因为压根没法记录(IO不可用)。</p><ul><li>1.本地log自动记录失效。</li><li>2.网络上报不可用。</li></ul><p>fd描述符被占满了导致文件和网络都不可用，这就是为什么，<strong>线上的设备（应用）挂了，而去拿日志的时候什么都没有的原因。</strong></p><h2 id="fd最大值"><a href="#fd最大值" class="headerlink" title="fd最大值"></a>fd最大值</h2><p>我们可以通过<code>/proc/pid/limits</code>,来查看当前进程允许使用的IO数目总量。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hx_s905x:/proc/4973 # cat limits                                                                      </span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units     </span><br><span class="line">Max cpu time              unlimited            unlimited            seconds   </span><br><span class="line">Max file size             unlimited            unlimited            bytes     </span><br><span class="line">Max data size             unlimited            unlimited            bytes     </span><br><span class="line">Max stack size            8388608              unlimited            bytes     </span><br><span class="line">Max core file size        0                    unlimited            bytes     </span><br><span class="line">Max resident set          unlimited            unlimited            bytes     </span><br><span class="line">Max processes             6811                 6811                 processes </span><br><span class="line">Max open files            1024                 1024                 files     </span><br><span class="line">Max locked memory         65536                65536                bytes     </span><br><span class="line">Max address space         unlimited            unlimited            bytes     </span><br><span class="line">Max file locks            unlimited            unlimited            locks     </span><br><span class="line">Max pending signals       6811                 6811                 signals   </span><br><span class="line">Max msgqueue size         819200               819200               bytes     </span><br><span class="line">Max nice priority         40                   40                   </span><br><span class="line">Max realtime priority     0                    0                    </span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br></pre></td></tr></table></figure><p>这里的 Max open files 字段就是指明我们的fd描述符允许被创建的总数。</p><h2 id="排查总结"><a href="#排查总结" class="headerlink" title="排查总结"></a>排查总结</h2><ul><li><strong>fd允许的最大值:</strong> <code>/proc/pid/limits</code></li><li><strong>获取当前应用的pid:</strong> <code>ps</code></li><li><strong>当前应用的状态:</strong> <code>/proc/pid/fd</code></li><li><strong>数量:</strong> <code>ls | wc -w</code></li></ul><p>我们只需要上面这些命令就可以了。检测的方式就是查看数目的抖动情况，如果维持比较平衡。不会出现不释放的情况则为正常。如果抖动情况很大，或者只增长不减少则存在fd泄漏。目前为止认知受限，还没弄明白为什么java层已经明确调用了释放但底层却没有释放的原因。不过我们可以在应用层控制频繁的创建和及时的检测，一般的App应用很少会遇见这种问题，因为用户用完就关了App。但是做平板、机顶盒、大屏触控（突然想起TNT工作站）等需要长时间运行的app。涉及到了频繁的网络创建和IO操作的就有可能会碰到。</p><p>上面的内容大部分是去年做的笔记，其本质是如果我们无法了解外围环境本身，就很有可能在当前的认知维度上做出错误的判断。假如当时我咬定是rom的错误，而不去学linux，基本上这个问题也就没法解决了。经常我会犯认知错误，就是站在自己所了解的情况，去认为一件事。结果往往还是错误的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程中android中io、socket、thread对于操作系统是什么？最多能创建多少个？&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://www.dajipai.cc/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>无效社交</title>
    <link href="http://www.dajipai.cc/archives/28d1a7a.html"/>
    <id>http://www.dajipai.cc/archives/28d1a7a.html</id>
    <published>2018-12-09T08:33:15.000Z</published>
    <updated>2018-12-09T11:11:54.582Z</updated>
    
    <content type="html"><![CDATA[<p>幼时人际关系结构逻辑简单，就是谁和我玩得来，我就和谁玩。玩久了就是好朋友。</p><a id="more"></a><p>从进大学开始慢慢的感受到了交际的力量。干啥都得需要有人在背后，如果你是一个窝在寝室的死宅。基本上除了室友也不会和谁再扯上关系，这样的人是存在的。但是我思索过一段时间，为什么他们不像很多新生一入学校就恨不得把各种社团、校学生会等组织都加入一个遍。因为他们并不依赖外部，说通俗一点就是不需要谁帮你的忙，解决一个什么事情。</p><p>到了期待出去实习找工作的时候，我感觉很无助，企图希望能遇上谁给我讲讲他的经历，给我指点一下我就可以不那么迷茫了。能想到最快的办法就是加兴趣群，就加xxx技术交流群吧，想必里面应该有很多在工作岗位上的前辈吧。最后我就发现这里根本没有人能帮我，除了发广告的和提细节bug问题的人。那我就想，要不我私加群主吧，想必群主这种热心肠生物能建群，岂能不管群友？现实再给了我一巴掌，没毛用，群主一般见小白见多了，上来就无脑QA。自己也很忙的，哪有功夫理你。又不欠你？你又没给他发红包。</p><p>到现在也能看到很多人在不断的见人就加好友，见群就进。生怕错失和某位大佬相认的时机。实际来看群里多半是在水群，会浪费你时间。很早之前我在某书上写过一篇文章说为什么你在群里提问却没人理你。原因很简单，因为这些社交成本太低。低到你没有给其他人带来任何价值。个人认为我们如果只是为了自己图方便去交际，那这种交际就是无效社会。</p><p>那么到底该怎么做，首先得让自己发光，我们能结交到的人，以及愿意和你说话说到一块去的。一般来说在社会阶层上是对等的。就像你不会和你瞧不起的人做朋友。这里没有刻意要把人分为三六九等的意思，只是多数情况下，社会结构就是这样的。就是说我们如果可以发光温暖其他人，那么其他人就会靠近你。而不是一个劲的跪舔大佬。</p><p>在我这个年纪，把时间花在提升自我上，要比花在交际上更有价值。我认为的有效社会，是建立在已有背景的条件下。毕竟没有到年过半百靠资源吃饭的年龄。共勉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;幼时人际关系结构逻辑简单，就是谁和我玩得来，我就和谁玩。玩久了就是好朋友。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.dajipai.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>知识付费</title>
    <link href="http://www.dajipai.cc/archives/5cd0a942.html"/>
    <id>http://www.dajipai.cc/archives/5cd0a942.html</id>
    <published>2018-12-02T04:25:22.000Z</published>
    <updated>2018-12-02T08:30:08.467Z</updated>
    
    <content type="html"><![CDATA[<ul><li>接受知识付费吗？</li><li>有不接受的吗？</li><li>时间和钱</li></ul><a id="more"></a><h2 id="接受知识付费吗？"><a href="#接受知识付费吗？" class="headerlink" title="接受知识付费吗？"></a>接受知识付费吗？</h2><p>接受！为什么有人说是在割韭菜，收智商税。但是还是有人在买。因为有市场需求。我觉得可以这样解释，我们想获得某种知识，但如果市面上资料寥寥无几，或者杂乱。你需要花更多的时间去啃、去过滤无意义的内容。这时如果有人跳出来说五毛钱给我们。想必原本要花更多的时间用钱就可以买回了。</p><h2 id="有不接受的吗？"><a href="#有不接受的吗？" class="headerlink" title="有不接受的吗？"></a>有不接受的吗？</h2><p>有，比如一门课程，我确定是否要买，取决于获得成本。我很少买编程类的课程，因为这是我所处熟悉的行业，这个行业只有通过多看多写和总结才能吸收（不含窄领域知识）。</p><p>但我又乐意给非软件行业知识付费，因为在其它领域我完全就是小白。我也就是想图个方便快速知道一下里面在讲个什么、玩个什么。</p><h2 id="时间和钱"><a href="#时间和钱" class="headerlink" title="时间和钱"></a>时间和钱</h2><p>越平穷，就越舍不得花钱。越舍不得花钱，就需要花更多的时间，把更多的时间花费在了低级消耗上就会变得更平穷。这有点儿像死循环。</p><p>举个例子。为了每个月能省下更多的钱宁可住在偏离公司远的地方，每天花两个小时在上班路上。上班不打出租车，只敢坐公交。那是因为当前的每天两个小时还赚不回出租车钱和公司附近的房租钱。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;接受知识付费吗？&lt;/li&gt;
&lt;li&gt;有不接受的吗？&lt;/li&gt;
&lt;li&gt;时间和钱&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.dajipai.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>最近和后面</title>
    <link href="http://www.dajipai.cc/archives/a8f25f46.html"/>
    <id>http://www.dajipai.cc/archives/a8f25f46.html</id>
    <published>2018-11-06T15:27:42.000Z</published>
    <updated>2018-12-02T08:30:00.350Z</updated>
    
    <content type="html"><![CDATA[<ul><li>物联网停更</li><li>最近</li><li>后面</li></ul><a id="more"></a><h3 id="物联网系列停更"><a href="#物联网系列停更" class="headerlink" title="物联网系列停更"></a>物联网系列停更</h3><p>停更是我没能想到的。两个月前板子和配套零件都买齐了。顺带还拉了一个淘宝的赞助商。准备全火力全开的做点有趣的东西，然后顺便把文章更了。意料之外的事情是工作的变更居然会有这么大的影响。人的精力果然是有限的。也许这块有空会继续做吧。（怕打脸，也许…也许..）</p><h3 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h3><p><strong>换工作</strong></p><p>应该从换工作说起，最早各种准备复习资料。修订简历，然后总结面试题目经验和技巧。分享了一些给需要的小伙伴。入职后不断的调整自己来快速进入新的环境。具体就是：工作的方式、侧重点和自己的短板。</p><p><strong>离开舒适区</strong></p><p>同时印证了如果一个人长期在某个岗位或领域做熟悉的工作，如果快到天花板后就难以再取得快速的进步。换工作后能马上发现周围原来有很多之前没有关注到的点值得去学习。</p><p><strong>向前辈学习</strong></p><p>新的工作环境中有许多了不起的人，也许自己看自己都没有什么感觉。可我站更低一阶层的角度往上看就会这样认为他们都是很牛的。这里不是说我之前的环境就辣鸡了，而是人不一样，带来的体验也不一样。时间长久了也会变得习惯。</p><h3 id="后面"><a href="#后面" class="headerlink" title="后面"></a>后面</h3><p><strong>技术路</strong></p><p>这个问题一直困扰着我，到底该不该走纯技术路线。比我有天赋的人多了去了。我很清楚大多数情况下我只是稍微多花了一些时间来学习工作上的技能。而就是这些多花的时间到底值不值得？从这两年的学习情况来看，编程的能力并没有得到什么提升，大多数时间花费在了熟悉这个那个API、框架之类的东西。</p><p><strong>下班</strong></p><p>我买了新的自行车，我很开心的能每天骑着它上下班。同样也给我创造了离开电脑的思考时间。其中问自己最多的一个问题是：我又在等周五，每天都是重复的？然后到家后心安理得的打开电脑刷一下github，star几个项目…然后呢？重复着过。不是有意要要传播什么负能量，而我认为这是像我这种普通程序员必须会要面对的问题。</p><p><strong>B计划</strong></p><p>B计划就是指替代写代码以外的生存方式，在合理的时候辞去现在的工作。是的没有错，我不只一次在心底里萌芽这个念头。从上学的时候就一直在想这个问题。目前而言不敢轻易的去尝试做一些我没有自认为靠谱的事情。从学校走到社会，认识了几个志同道合的朋友，只要相遇必定喋喋不休。但说来也很巧，并不是和所有人都能讲这些。其中多次和毛同学谈论创业。但最终我还是对项目本身保佑质疑的态度，就没参合了。自认为太年轻，对项目的控制力和市场感知能力还不足以支撑我去做这些。一股热血冲进去，恐怕会撞个头破血流出来。（我是较保守型的人）</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;物联网停更&lt;/li&gt;
&lt;li&gt;最近&lt;/li&gt;
&lt;li&gt;后面&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.dajipai.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Android与物联网设备通信-利用UDP广播来做设备查找</title>
    <link href="http://www.dajipai.cc/archives/ead4653c.html"/>
    <id>http://www.dajipai.cc/archives/ead4653c.html</id>
    <published>2018-08-10T04:50:37.000Z</published>
    <updated>2018-10-12T17:52:59.071Z</updated>
    
    <content type="html"><![CDATA[<p><strong>“三年级六班李子明同学,你妈妈拿了两罐旺仔牛奶要给你！”…..</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-4239d557fe5575a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" alt="image.png"></p><p>什么是广播？你还记得上小学的时候广播站大喇叭吗？没有错。就是在一个大家都能听到的场景下对着一个口子传递信息。也许都能听到，但是对于广播的接受者只关注自己需要的信息。</p><a id="more"></a><hr><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><ul><li><a href="http://www.dajipai.cc/archives/fe5f6231.html">Android与物联网设备通信-概念入门</a></li><li><a href="http://www.dajipai.cc/archives/f1d847c5.html">Android与物联网设备通信-数据传递的本质</a></li><li><a href="http://www.dajipai.cc/archives/dcba528a.html">Android与物联网设备通信-网络模型分层</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-UDP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-TCP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-基于TCP/IP自定义报文</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-什么是字节序</a></li><li><a href="http://www.dajipai.cc/archives/22074801.html">Android与物联网设备通信- 字节报文组装与解析</a></li><li><a href="http://www.dajipai.cc/archives/ead4653c.html">Android与物联网设备通信-利用UDP广播来做设备查找</a></li><li>Android与物联网设备通信-实现远程控制Android客户端</li><li>Android与物联网设备通信-Android做小型服务器</li><li>Android与物联网设备通信-调试技巧</li><li>Android与物联网设备通信-并行串行与队列</li><li>Android与物联网设备通信-数据安全</li><li>Android与物联网设备通信-心跳</li><li>Android与物联网设备通信-网络IO模型</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>需求</li><li>思路与原理</li><li>实现</li><li>总结</li></ul><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p> 我们接着空调说，你现在是xx智能空调的Android物联工程师。</p><p> 你现在拥有硬件：</p><ul><li>wifi空调 x3</li><li>Android设备 x1</li><li>wifi的路由器 x1</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1110736-854548c2436d80e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="image.png"></p><p>你研发的空调设备和Android设备已连接到路由上，它们已被分配各自的内网IP地址。<br>我们需要通过某种方式来使手机和空调之间能互相识别。</p><h2 id="思路与原理"><a href="#思路与原理" class="headerlink" title="思路与原理"></a>思路与原理</h2><p> 根据上面的条件我们可以分析到它们通过路由器的方式形成了一个局域网。而设备只要在局域网中就具备了UDP的能力,我们可以利用UDP的广播报文功能做查找设备。（请熟知广播、多播、单播知识）</p><p> UDP广播我们只需要利用广播的特性，向固定的端口发送数据即可。而IP使用固定的广播地址<code>255.255.255.255</code>。<br> 下面我画一下流程。</p><p> <img src="https://upload-images.jianshu.io/upload_images/1110736-f57739b37a14138c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="image.png"></p><p>这个流程很简单，我们通过手机发送一组UDP广播，然后开启监听等待设备响应手机。当局域网中存在多台设备的时候设备会把自己的设备号以及IP地址回复给手机。此时在手机上就会收到多台空调的回复报文。这时我们只需要针对SN做业务区别。一般是针对不同的SN取别名。（别名有利于人识别，比如卧室空调、客厅空调等）我们通常把这个过程称作<strong>握手协议</strong>或<strong>搜索配对协议</strong>。</p><p>这里我想抛出一个问题让读者思考，设备首次连接路由时怎么填入wifi密码呢？方法有很多，甚至有些方案都已经成熟到硬件厂商帮办了。希望我们能有自己的思考。</p><p>下面我说下我知道的几种方案：</p><ul><li>1.设备自带AP先开热点让手机连接，当连接后按照私有协议把设备需要连接的ssid和密码填入。</li><li>2.设备带蓝牙功能，通过蓝牙和手机配对后连接wifi。</li><li>3.利用802.11的物理层协议的Length字段做透传。代表厂商产品有SmartConfig、AirKiss方案等。</li><li>4.NFC感应射频等。</li><li>5.声波透传。</li></ul><p>上述方案中利用802.11协议的方案可能是最节省硬件成本的，其余方案均要搭配其它元器件模块等。但是该方案会导致某些特殊型号的路由器上失效，目前博主暂未找到原因，可能和路由厂商对协议加密导致的。在实际环境场景中可以借助第二台手机开热点搞定。总之没有最优的方案，只有最符合工程需求的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>不占篇幅，这里就不贴完整代码了，<strong>重要的是思路、重要的是思路、重要的是思路。</strong></p><p>下面是发送UDP报文的关键代码。就是前面几章所有的知识点的汇集。把协议定好，按照协议拆解报文即可。</p><p>提供几个关键的对象供参考：</p><ul><li><strong>DatagramSocket</strong> 含发送和监听方法</li><li><strong>InetSocketAddress</strong> 地址和端口关系</li><li><strong>DatagramPacket</strong> 数据包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void sendData(String host, int port, byte[] data)  &#123;</span><br><span class="line">       clientSocket = new DatagramSocket();         </span><br><span class="line">       serverAddress = new InetSocketAddress(host, port);  </span><br><span class="line">       DatagramPacket packet = new DatagramPacket(data, data.length, serverAddress);</span><br><span class="line">       clientSocket.send(packet);</span><br><span class="line">       clientSocket.close();</span><br><span class="line">       Log.d(TGA, &quot;---&gt;端口：&quot; + port + &quot; \n DATA:&quot; + bytesToHexString(data, data.length));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>值得注意的是UDP报文因为它是不可靠协议，我们需要自己在设计协议时带上可识别头字段和数据校验。</p><hr><p>( ′◔ ‸◔`) 一拖再拖，一个月过去了，文章严重拖进度了。各种七七八八的事情。没有更多的时间留给我写博客。总算安稳的在上海安顿了下来。下周就要踏入新公司的旅途。希望我还能在周末抽出时间写文章。哈哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;“三年级六班李子明同学,你妈妈拿了两罐旺仔牛奶要给你！”…..&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1110736-4239d557fe5575a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;什么是广播？你还记得上小学的时候广播站大喇叭吗？没有错。就是在一个大家都能听到的场景下对着一个口子传递信息。也许都能听到，但是对于广播的接受者只关注自己需要的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="物联网" scheme="http://www.dajipai.cc/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Android与物联网设备通信 - 字节报文组装与解析</title>
    <link href="http://www.dajipai.cc/archives/22074801.html"/>
    <id>http://www.dajipai.cc/archives/22074801.html</id>
    <published>2018-07-07T16:23:33.000Z</published>
    <updated>2018-10-12T17:52:59.071Z</updated>
    
    <content type="html"><![CDATA[<p>工作调动。暂时停更了一段时间。续上一篇我们学习了如何去自定义一组报文，今天我们接着解析和组装报文。<br>前面我们讲过在物联网通信中实际上不论我们使用什么方式作为通信介质，其本质就是字节。所以我再一次对本章节的内容进行了调整，我们不讲Socket和ServerSocket这两个阻塞式IO Socket如何写。那个意义不大。<br><a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/1110736-53f83f51766c33df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>也正式因为在上一节中有读者提出说需要知道报文该如何拆解就有了这一篇。</p><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><ul><li><a href="http://www.dajipai.cc/archives/fe5f6231.html">Android与物联网设备通信-概念入门</a></li><li><a href="http://www.dajipai.cc/archives/f1d847c5.html">Android与物联网设备通信-数据传递的本质</a></li><li><a href="http://www.dajipai.cc/archives/dcba528a.html">Android与物联网设备通信-网络模型分层</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-UDP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-TCP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-基于TCP/IP自定义报文</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-什么是字节序</a></li><li><a href="http://www.dajipai.cc/archives/22074801.html">Android与物联网设备通信- 字节报文组装与解析</a></li><li><a href="http://www.dajipai.cc/archives/ead4653c.html">Android与物联网设备通信-利用UDP广播来做设备查找</a></li><li>Android与物联网设备通信-实现远程控制Android客户端</li><li>Android与物联网设备通信-Android做小型服务器</li><li>Android与物联网设备通信-调试技巧</li><li>Android与物联网设备通信-并行串行与队列</li><li>Android与物联网设备通信-数据安全</li><li>Android与物联网设备通信-心跳</li><li>Android与物联网设备通信-网络IO模型</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>组装报文</li><li>解析报文</li><li>总结</li></ul><hr><h2 id="组装报文"><a href="#组装报文" class="headerlink" title="组装报文"></a>组装报文</h2><p>接上一节的功能拿来，我们到底是怎么做到把下面的结构体转换成字节的呢？</p><p><strong>协议：</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-a997d4071b00fdf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-ff5a414f988f009b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>转换后的字节：</strong></p><p><code>0x00 0x00 0x00 0x11 | 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33 | 0x21 | 0x01  |0x57 0x9D</code></p><p>首先我们需要定义一个对象，当做结构体。(不明白为什么要这样定义的同学请看上一节文章)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCondBaseStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">byte</span> sn[]; <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">byte</span> code; <span class="comment">//功能码</span></span><br><span class="line">    <span class="keyword">byte</span> data[]; <span class="comment">//透传数据</span></span><br><span class="line">    <span class="keyword">byte</span> crc[]; <span class="comment">//校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对这个结构体，我们再写一个枚举：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CodeEnum &#123;</span><br><span class="line">    POWER((<span class="keyword">byte</span>) <span class="number">0x21</span>),<span class="comment">//开关</span></span><br><span class="line">    MODE((<span class="keyword">byte</span>) <span class="number">0x22</span>),<span class="comment">//模式</span></span><br><span class="line">    TEMPERATURE((<span class="keyword">byte</span>) <span class="number">0x23</span>);<span class="comment">//温度</span></span><br><span class="line">    <span class="keyword">byte</span> code;</span><br><span class="line">    CodeEnum(<span class="keyword">byte</span> i) &#123;</span><br><span class="line">        code = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该枚举器正好对应功能对照表里的功能。</p><p>写一下构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AirCondBaseStructure</span><span class="params">(String sn, AirCondBaseStructure.CodeEnum code, <span class="keyword">byte</span>[] data)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sn = sn.getBytes(); <span class="comment">// 序列号</span></span><br><span class="line">      <span class="keyword">this</span>.code = code.code;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">      <span class="keyword">this</span>.len=computeLen();<span class="comment">//获取长度</span></span><br><span class="line">      <span class="keyword">this</span>.crc =computeCrc();<span class="comment">//校验</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这里构造方法只传入三个参数:</p><ul><li>序列号</li><li>功能</li><li>透传内容</li></ul><p>可以看到实际里面还有<code>长度</code>和<code>crc校验</code>。是根据<code>computeLen();</code>和<code>computeCrc();</code>来自动完成计算的。</p><p>computeLen方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeLen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sn.length + <span class="number">1</span><span class="comment">/*功能码长度*/</span> + data.length + <span class="number">2</span><span class="comment">/*校验和*/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的长度是固定字段+可变长。</p><p>computeCrc方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 计算crc</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private byte[] computeCrc() &#123;</span><br><span class="line">    byte[] crc=new byte[2];</span><br><span class="line">    byte[] datas=null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);</span><br><span class="line">        dataOutputStream.writeInt(len);</span><br><span class="line">        dataOutputStream.write(sn);</span><br><span class="line">        dataOutputStream.writeByte(code);</span><br><span class="line">        dataOutputStream.write(data);</span><br><span class="line">        dataOutputStream.flush();</span><br><span class="line">         datas = byteArrayOutputStream.toByteArray();</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    CRC16M crc16 = new CRC16M();</span><br><span class="line">    crc16.update(datas, datas.length);</span><br><span class="line">    int ri = crc16.getValue();</span><br><span class="line">    crc[0] = (byte) ((0xff00 &amp; ri) &gt;&gt; 8);</span><br><span class="line">    crc[1] = (byte) (0xff &amp; ri);</span><br><span class="line">    return crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>crc校验是使用是<code>crc16/modbus</code>标准。完整代码后面贴出来。</p><p>最后是把报文组合起来变成字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 序列化</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public byte[] toBytes()&#123;</span><br><span class="line">    byte[] datas=null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);</span><br><span class="line">        dataOutputStream.writeInt(len);</span><br><span class="line">        dataOutputStream.write(sn);</span><br><span class="line">        dataOutputStream.writeByte(code);</span><br><span class="line">        dataOutputStream.write(data);</span><br><span class="line">        dataOutputStream.write(crc);</span><br><span class="line">        dataOutputStream.flush();</span><br><span class="line">        datas = byteArrayOutputStream.toByteArray();</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return datas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们使用的就是ByteArrayOutputStream+DataOutputStream把对应的字段按照顺序写入，以保证和协议一致。</p><p>最后我们看看一下使用结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String sn=<span class="string">"1234567890123"</span>;</span><br><span class="line">      AirCondBaseStructure powerOpen =<span class="keyword">new</span> AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.POWER, <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x01</span>&#125;);</span><br><span class="line">      System.out.println(<span class="string">"空调打开报文："</span>+hex2Str(powerOpen.toBytes()));</span><br><span class="line"></span><br><span class="line">      AirCondBaseStructure powerCloce =<span class="keyword">new</span> AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.POWER, <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>)<span class="number">0x00</span>&#125;);</span><br><span class="line">      System.out.println(<span class="string">"空调关闭报文："</span>+hex2Str(powerCloce.toBytes()));</span><br><span class="line"></span><br><span class="line">      AirCondBaseStructure modeAuto =<span class="keyword">new</span> AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.MODE, <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>)<span class="number">0x03</span>&#125;);</span><br><span class="line">      System.out.println(<span class="string">"空调自动报文："</span>+hex2Str(modeAuto.toBytes()));</span><br><span class="line"></span><br><span class="line">      AirCondBaseStructure modeDeh =<span class="keyword">new</span> AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.MODE, <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>)<span class="number">0x05</span>&#125;);</span><br><span class="line">      System.out.println(<span class="string">"空调除湿报文："</span>+hex2Str(modeDeh.toBytes()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      AirCondBaseStructure temperature =<span class="keyword">new</span> AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.TEMPERATURE,  <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;(<span class="keyword">byte</span>)<span class="number">0x00</span>, (<span class="keyword">byte</span>) <span class="number">0x19</span>&#125;);</span><br><span class="line">      System.out.println(<span class="string">"空调25度报文："</span>+hex2Str(temperature.toBytes()));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>对上层而言组装的方式比较简单，只需要把对应的枚举功能设置进去，带上该有的数据，剩下的序列化和校验均在内部实现。</p><p>这里我们模拟了五组报文，输出结果如下。</p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空调打开报文：0x00 0x00 0x00 0x11 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33 0x21 0x01 0x57 0x9D </span><br><span class="line">空调关闭报文：0x00 0x00 0x00 0x11 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33 0x21 0x00 0x96 0x5D </span><br><span class="line">空调自动报文：0x00 0x00 0x00 0x11 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33 0x22 0x03 0xD6 0xAC </span><br><span class="line">空调除湿报文：0x00 0x00 0x00 0x11 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33 0x22 0x05 0x56 0xAE </span><br><span class="line">空调25度报文：0x00 0x00 0x00 0x12 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33 0x23 0x00 0x19 0x4D 0x94</span><br></pre></td></tr></table></figure></p><p>我们来细看一下他们的变化。<br><img src="https://upload-images.jianshu.io/upload_images/1110736-c0320320749d27d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>到这里我们就已经将报文组装好并转换成了字节数组。</p><p>也许我们此时会想，那怎么发出去呢？我们前面第一节就讲过其实并不管中间用什么在传输。他们最后都是字节或二进制的形式。所以我们都已经转换好了，剩下的都是很简单的事情了。就是把数据喂进去，喂给TCP/IP、UDP、蓝牙、红外、无线电、声波、电磁波….看实际情况来了。</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Bolex on 2018/6/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCondBaseStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">byte</span> sn[]; <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">byte</span> code; <span class="comment">//功能码</span></span><br><span class="line">    <span class="keyword">byte</span> data[]; <span class="comment">//透传数据</span></span><br><span class="line">    <span class="keyword">byte</span> crc[]; <span class="comment">//校验</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AirCondBaseStructure</span><span class="params">(String sn, AirCondBaseStructure.CodeEnum code, <span class="keyword">byte</span>[] data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sn = sn.getBytes(); <span class="comment">// 序列号</span></span><br><span class="line">        <span class="keyword">this</span>.code = code.code;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.len=computeLen();<span class="comment">//获取长度</span></span><br><span class="line">        <span class="keyword">this</span>.crc =computeCrc();<span class="comment">//校验</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> CodeEnum &#123;</span><br><span class="line">        POWER((<span class="keyword">byte</span>) <span class="number">0x21</span>),<span class="comment">//开关</span></span><br><span class="line">        MODE((<span class="keyword">byte</span>) <span class="number">0x22</span>),<span class="comment">//模式</span></span><br><span class="line">        TEMPERATURE((<span class="keyword">byte</span>) <span class="number">0x23</span>);<span class="comment">//温度</span></span><br><span class="line">        <span class="keyword">byte</span> code;</span><br><span class="line">        CodeEnum(<span class="keyword">byte</span> i) &#123;</span><br><span class="line">            code = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeLen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sn.length + <span class="number">1</span><span class="comment">/*功能码长度*/</span> + data.length + <span class="number">2</span><span class="comment">/*校验和*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算crc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] computeCrc() &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] crc=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] datas=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(byteArrayOutputStream);</span><br><span class="line">            dataOutputStream.writeInt(len);</span><br><span class="line">            dataOutputStream.write(sn);</span><br><span class="line">            dataOutputStream.writeByte(code);</span><br><span class="line">            dataOutputStream.write(data);</span><br><span class="line">            dataOutputStream.flush();</span><br><span class="line">             datas = byteArrayOutputStream.toByteArray();</span><br><span class="line">            dataOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        CRC16M crc16 = <span class="keyword">new</span> CRC16M();</span><br><span class="line">        crc16.update(datas, datas.length);</span><br><span class="line">        <span class="keyword">int</span> ri = crc16.getValue();</span><br><span class="line">        crc[<span class="number">0</span>] = (<span class="keyword">byte</span>) ((<span class="number">0xff00</span> &amp; ri) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        crc[<span class="number">1</span>] = (<span class="keyword">byte</span>) (<span class="number">0xff</span> &amp; ri);</span><br><span class="line">        <span class="keyword">return</span> crc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] toBytes()&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] datas=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(byteArrayOutputStream);</span><br><span class="line">            dataOutputStream.writeInt(len);</span><br><span class="line">            dataOutputStream.write(sn);</span><br><span class="line">            dataOutputStream.writeByte(code);</span><br><span class="line">            dataOutputStream.write(data);</span><br><span class="line">            dataOutputStream.write(crc);</span><br><span class="line">            dataOutputStream.flush();</span><br><span class="line">            datas = byteArrayOutputStream.toByteArray();</span><br><span class="line">            dataOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> datas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class CRC16M &#123;</span><br><span class="line"></span><br><span class="line">byte uchCRCHi = (byte) 0xFF;</span><br><span class="line">byte uchCRCLo = (byte) 0xFF;</span><br><span class="line">private static byte[] auchCRCHi = &#123; 0x00, (byte) 0xC1, (byte) 0x81,</span><br><span class="line">(byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41,</span><br><span class="line">(byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00,</span><br><span class="line">(byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0,</span><br><span class="line">(byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81,</span><br><span class="line">(byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40,</span><br><span class="line">(byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01,</span><br><span class="line">(byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1,</span><br><span class="line">(byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81,</span><br><span class="line">(byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41,</span><br><span class="line">(byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01,</span><br><span class="line">(byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0,</span><br><span class="line">(byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81,</span><br><span class="line">(byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41,</span><br><span class="line">(byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00,</span><br><span class="line">(byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0,</span><br><span class="line">(byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81,</span><br><span class="line">(byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41,</span><br><span class="line">(byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00,</span><br><span class="line">(byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1,</span><br><span class="line">(byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80,</span><br><span class="line">(byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41,</span><br><span class="line">(byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01,</span><br><span class="line">(byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1,</span><br><span class="line">(byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81,</span><br><span class="line">(byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41,</span><br><span class="line">(byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00,</span><br><span class="line">(byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1,</span><br><span class="line">(byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80,</span><br><span class="line">(byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40,</span><br><span class="line">(byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x01,</span><br><span class="line">(byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1,</span><br><span class="line">(byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81,</span><br><span class="line">(byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41,</span><br><span class="line">(byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00,</span><br><span class="line">(byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0,</span><br><span class="line">(byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81,</span><br><span class="line">(byte) 0x40, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40,</span><br><span class="line">(byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00,</span><br><span class="line">(byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0,</span><br><span class="line">(byte) 0x80, (byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80,</span><br><span class="line">(byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40,</span><br><span class="line">(byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00,</span><br><span class="line">(byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00, (byte) 0xC1,</span><br><span class="line">(byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80,</span><br><span class="line">(byte) 0x41, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41,</span><br><span class="line">(byte) 0x00, (byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x00,</span><br><span class="line">(byte) 0xC1, (byte) 0x81, (byte) 0x40, (byte) 0x01, (byte) 0xC0,</span><br><span class="line">(byte) 0x80, (byte) 0x41, (byte) 0x00, (byte) 0xC1, (byte) 0x81,</span><br><span class="line">(byte) 0x40, (byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41,</span><br><span class="line">(byte) 0x01, (byte) 0xC0, (byte) 0x80, (byte) 0x41, (byte) 0x00,</span><br><span class="line">(byte) 0xC1, (byte) 0x81, (byte) 0x40 &#125;;</span><br><span class="line"></span><br><span class="line">private static byte[] auchCRCLo = &#123; (byte) 0x00, (byte) 0xC0, (byte) 0xC1,</span><br><span class="line">(byte) 0x01, (byte) 0xC3, (byte) 0x03, (byte) 0x02, (byte) 0xC2,</span><br><span class="line">(byte) 0xC6, (byte) 0x06, (byte) 0x07, (byte) 0xC7, (byte) 0x05,</span><br><span class="line">(byte) 0xC5, (byte) 0xC4, (byte) 0x04, (byte) 0xCC, (byte) 0x0C,</span><br><span class="line">(byte) 0x0D, (byte) 0xCD, (byte) 0x0F, (byte) 0xCF, (byte) 0xCE,</span><br><span class="line">(byte) 0x0E, (byte) 0x0A, (byte) 0xCA, (byte) 0xCB, (byte) 0x0B,</span><br><span class="line">(byte) 0xC9, (byte) 0x09, (byte) 0x08, (byte) 0xC8, (byte) 0xD8,</span><br><span class="line">(byte) 0x18, (byte) 0x19, (byte) 0xD9, (byte) 0x1B, (byte) 0xDB,</span><br><span class="line">(byte) 0xDA, (byte) 0x1A, (byte) 0x1E, (byte) 0xDE, (byte) 0xDF,</span><br><span class="line">(byte) 0x1F, (byte) 0xDD, (byte) 0x1D, (byte) 0x1C, (byte) 0xDC,</span><br><span class="line">(byte) 0x14, (byte) 0xD4, (byte) 0xD5, (byte) 0x15, (byte) 0xD7,</span><br><span class="line">(byte) 0x17, (byte) 0x16, (byte) 0xD6, (byte) 0xD2, (byte) 0x12,</span><br><span class="line">(byte) 0x13, (byte) 0xD3, (byte) 0x11, (byte) 0xD1, (byte) 0xD0,</span><br><span class="line">(byte) 0x10, (byte) 0xF0, (byte) 0x30, (byte) 0x31, (byte) 0xF1,</span><br><span class="line">(byte) 0x33, (byte) 0xF3, (byte) 0xF2, (byte) 0x32, (byte) 0x36,</span><br><span class="line">(byte) 0xF6, (byte) 0xF7, (byte) 0x37, (byte) 0xF5, (byte) 0x35,</span><br><span class="line">(byte) 0x34, (byte) 0xF4, (byte) 0x3C, (byte) 0xFC, (byte) 0xFD,</span><br><span class="line">(byte) 0x3D, (byte) 0xFF, (byte) 0x3F, (byte) 0x3E, (byte) 0xFE,</span><br><span class="line">(byte) 0xFA, (byte) 0x3A, (byte) 0x3B, (byte) 0xFB, (byte) 0x39,</span><br><span class="line">(byte) 0xF9, (byte) 0xF8, (byte) 0x38, (byte) 0x28, (byte) 0xE8,</span><br><span class="line">(byte) 0xE9, (byte) 0x29, (byte) 0xEB, (byte) 0x2B, (byte) 0x2A,</span><br><span class="line">(byte) 0xEA, (byte) 0xEE, (byte) 0x2E, (byte) 0x2F, (byte) 0xEF,</span><br><span class="line">(byte) 0x2D, (byte) 0xED, (byte) 0xEC, (byte) 0x2C, (byte) 0xE4,</span><br><span class="line">(byte) 0x24, (byte) 0x25, (byte) 0xE5, (byte) 0x27, (byte) 0xE7,</span><br><span class="line">(byte) 0xE6, (byte) 0x26, (byte) 0x22, (byte) 0xE2, (byte) 0xE3,</span><br><span class="line">(byte) 0x23, (byte) 0xE1, (byte) 0x21, (byte) 0x20, (byte) 0xE0,</span><br><span class="line">(byte) 0xA0, (byte) 0x60, (byte) 0x61, (byte) 0xA1, (byte) 0x63,</span><br><span class="line">(byte) 0xA3, (byte) 0xA2, (byte) 0x62, (byte) 0x66, (byte) 0xA6,</span><br><span class="line">(byte) 0xA7, (byte) 0x67, (byte) 0xA5, (byte) 0x65, (byte) 0x64,</span><br><span class="line">(byte) 0xA4, (byte) 0x6C, (byte) 0xAC, (byte) 0xAD, (byte) 0x6D,</span><br><span class="line">(byte) 0xAF, (byte) 0x6F, (byte) 0x6E, (byte) 0xAE, (byte) 0xAA,</span><br><span class="line">(byte) 0x6A, (byte) 0x6B, (byte) 0xAB, (byte) 0x69, (byte) 0xA9,</span><br><span class="line">(byte) 0xA8, (byte) 0x68, (byte) 0x78, (byte) 0xB8, (byte) 0xB9,</span><br><span class="line">(byte) 0x79, (byte) 0xBB, (byte) 0x7B, (byte) 0x7A, (byte) 0xBA,</span><br><span class="line">(byte) 0xBE, (byte) 0x7E, (byte) 0x7F, (byte) 0xBF, (byte) 0x7D,</span><br><span class="line">(byte) 0xBD, (byte) 0xBC, (byte) 0x7C, (byte) 0xB4, (byte) 0x74,</span><br><span class="line">(byte) 0x75, (byte) 0xB5, (byte) 0x77, (byte) 0xB7, (byte) 0xB6,</span><br><span class="line">(byte) 0x76, (byte) 0x72, (byte) 0xB2, (byte) 0xB3, (byte) 0x73,</span><br><span class="line">(byte) 0xB1, (byte) 0x71, (byte) 0x70, (byte) 0xB0, (byte) 0x50,</span><br><span class="line">(byte) 0x90, (byte) 0x91, (byte) 0x51, (byte) 0x93, (byte) 0x53,</span><br><span class="line">(byte) 0x52, (byte) 0x92, (byte) 0x96, (byte) 0x56, (byte) 0x57,</span><br><span class="line">(byte) 0x97, (byte) 0x55, (byte) 0x95, (byte) 0x94, (byte) 0x54,</span><br><span class="line">(byte) 0x9C, (byte) 0x5C, (byte) 0x5D, (byte) 0x9D, (byte) 0x5F,</span><br><span class="line">(byte) 0x9F, (byte) 0x9E, (byte) 0x5E, (byte) 0x5A, (byte) 0x9A,</span><br><span class="line">(byte) 0x9B, (byte) 0x5B, (byte) 0x99, (byte) 0x59, (byte) 0x58,</span><br><span class="line">(byte) 0x98, (byte) 0x88, (byte) 0x48, (byte) 0x49, (byte) 0x89,</span><br><span class="line">(byte) 0x4B, (byte) 0x8B, (byte) 0x8A, (byte) 0x4A, (byte) 0x4E,</span><br><span class="line">(byte) 0x8E, (byte) 0x8F, (byte) 0x4F, (byte) 0x8D, (byte) 0x4D,</span><br><span class="line">(byte) 0x4C, (byte) 0x8C, (byte) 0x44, (byte) 0x84, (byte) 0x85,</span><br><span class="line">(byte) 0x45, (byte) 0x87, (byte) 0x47, (byte) 0x46, (byte) 0x86,</span><br><span class="line">(byte) 0x82, (byte) 0x42, (byte) 0x43, (byte) 0x83, (byte) 0x41,</span><br><span class="line">(byte) 0x81, (byte) 0x80, (byte) 0x40 &#125;;</span><br><span class="line"></span><br><span class="line">public int value;</span><br><span class="line"></span><br><span class="line">public CRC16M() &#123;</span><br><span class="line">value = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void update(byte[] puchMsg, int usDataLen) &#123;</span><br><span class="line">int uIndex;</span><br><span class="line">for (int i = 0; i &lt; usDataLen; i++) &#123;</span><br><span class="line">uIndex = (uchCRCHi ^ puchMsg[i]) &amp; 0xff;</span><br><span class="line"></span><br><span class="line">uchCRCHi = (byte) (uchCRCLo ^ auchCRCHi[uIndex]);</span><br><span class="line">uchCRCLo = auchCRCLo[uIndex];</span><br><span class="line">&#125;</span><br><span class="line">value = ((((int) uchCRCHi) &lt;&lt; 8 | (((int) uchCRCLo) &amp; 0xff))) &amp; 0xffff;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reset() &#123;</span><br><span class="line">value = 0;</span><br><span class="line">uchCRCHi = (byte) 0xff;</span><br><span class="line">uchCRCLo = (byte) 0xff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getValue() &#123;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static byte uniteBytes(byte src0, byte src1) &#123;</span><br><span class="line">byte _b0 = Byte.decode(&quot;0x&quot; + new String(new byte[] &#123; src0 &#125;))</span><br><span class="line">.byteValue();</span><br><span class="line">_b0 = (byte) (_b0 &lt;&lt; 4);</span><br><span class="line">byte _b1 = Byte.decode(&quot;0x&quot; + new String(new byte[] &#123; src1 &#125;))</span><br><span class="line">.byteValue();</span><br><span class="line">byte ret = (byte) (_b0 ^ _b1);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static byte[] HexString2Buf(String src) &#123;</span><br><span class="line">int len = src.length();</span><br><span class="line">byte[] ret = new byte[len / 2+2];</span><br><span class="line">byte[] tmp = src.getBytes();</span><br><span class="line">for (int i = 0; i &lt; len; i += 2) &#123;</span><br><span class="line">ret[i / 2] = uniteBytes(tmp[i], tmp[i + 1]);</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static byte[] getSendBuf(String toSend)&#123;</span><br><span class="line">byte[] bb = HexString2Buf(toSend);</span><br><span class="line">CRC16M crc16 = new CRC16M();</span><br><span class="line">crc16.update(bb, bb.length-2);</span><br><span class="line">int ri = crc16.getValue();</span><br><span class="line">bb[bb.length-1]=(byte) (0xff &amp; ri);</span><br><span class="line">bb[bb.length-2]=(byte) ((0xff00 &amp; ri) &gt;&gt; 8);</span><br><span class="line">return bb;</span><br><span class="line">&#125;</span><br><span class="line">public static boolean checkBuf(byte[] bb)&#123;</span><br><span class="line">CRC16M crc16 = new CRC16M();</span><br><span class="line">crc16.update(bb, bb.length-2);</span><br><span class="line">int ri = crc16.getValue();</span><br><span class="line">if(bb[bb.length-1]==(byte)(ri&amp;0xff) </span><br><span class="line">&amp;&amp; bb[bb.length-2]==(byte) ((0xff00 &amp; ri) &gt;&gt; 8))</span><br><span class="line">return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Bolex on 2018/6/17.</span><br><span class="line"> */</span><br><span class="line">public class AirCondMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String sn=&quot;1234567890123&quot;;</span><br><span class="line">        AirCondBaseStructure powerOpen =new AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.POWER, new byte[]&#123;0x01&#125;);</span><br><span class="line">        System.out.println(&quot;空调打开报文：&quot;+hex2Str(powerOpen.toBytes()));</span><br><span class="line"></span><br><span class="line">        AirCondBaseStructure powerCloce =new AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.POWER, new byte[]&#123;(byte)0x00&#125;);</span><br><span class="line">        System.out.println(&quot;空调关闭报文：&quot;+hex2Str(powerCloce.toBytes()));</span><br><span class="line"></span><br><span class="line">        AirCondBaseStructure modeAuto =new AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.MODE, new byte[]&#123;(byte)0x03&#125;);</span><br><span class="line">        System.out.println(&quot;空调自动报文：&quot;+hex2Str(modeAuto.toBytes()));</span><br><span class="line"></span><br><span class="line">        AirCondBaseStructure modeDeh =new AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.MODE, new byte[]&#123;(byte)0x05&#125;);</span><br><span class="line">        System.out.println(&quot;空调除湿报文：&quot;+hex2Str(modeDeh.toBytes()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AirCondBaseStructure temperature =new AirCondBaseStructure(sn, AirCondBaseStructure.CodeEnum.TEMPERATURE,  new byte[]&#123;(byte)0x00, (byte) 0x19&#125;);</span><br><span class="line">        System.out.println(&quot;空调25度报文：&quot;+hex2Str(temperature.toBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     static String hex2Str(byte[] raw)&#123;</span><br><span class="line">        String HEXES = &quot;0123456789ABCDEF&quot;;</span><br><span class="line">        if ( raw == null ) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        final StringBuilder hex = new StringBuilder( 2 * raw.length );</span><br><span class="line">        for ( final byte b : raw ) &#123;</span><br><span class="line">            hex.append(&quot;0x&quot;);</span><br><span class="line">            hex.append(HEXES.charAt((b &amp; 0xF0) &gt;&gt; 4))</span><br><span class="line">                    .append(HEXES.charAt((b &amp; 0x0F)));</span><br><span class="line">            hex.append(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return hex.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="解析报文"><a href="#解析报文" class="headerlink" title="解析报文"></a>解析报文</h2><p>解析报文的过程就是把字节数组再反过来转换成对象，也叫反序列化。</p><p>这里由于是文章演示（偷懒），就不像前面组装报文的时候再做封装了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Bolex on 2018/6/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCondAnalyzeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] powerOpenBytes = hexStringToBytes(<span class="string">"00000011313233343536373839303132332101579D"</span>);</span><br><span class="line">        ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(powerOpenBytes);</span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(byteArrayInputStream);</span><br><span class="line">        <span class="keyword">int</span> len = dis.readInt(); <span class="comment">//报长</span></span><br><span class="line">        <span class="keyword">byte</span>[] sn = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">13</span>]; <span class="comment">//序列号</span></span><br><span class="line">        <span class="keyword">byte</span>[] code = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span>]; <span class="comment">//功能码</span></span><br><span class="line">        <span class="keyword">byte</span>[] crc = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>]; <span class="comment">//校验</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len - sn.length - code.length - crc.length];</span><br><span class="line">        dis.read(sn);</span><br><span class="line">        dis.read(code);</span><br><span class="line">        dis.read(data);</span><br><span class="line">        dis.read(crc);</span><br><span class="line">        System.out.println(<span class="string">"报文长度："</span> + len);</span><br><span class="line">        System.out.println(<span class="string">"sn："</span> + <span class="keyword">new</span> String(sn));</span><br><span class="line">        System.out.println(<span class="string">"功能码："</span> + hex2Str(code));</span><br><span class="line">        System.out.println(<span class="string">"数据："</span> + hex2Str(data));</span><br><span class="line">        System.out.println(<span class="string">"校验："</span> + hex2Str(crc));</span><br><span class="line">         dis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] hexStringToBytes(String hexString) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hexString == <span class="keyword">null</span> || hexString.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hexString = hexString.toUpperCase();</span><br><span class="line">        <span class="keyword">int</span> length = hexString.length() / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">char</span>[] hexChars = hexString.toCharArray();</span><br><span class="line">        <span class="keyword">byte</span>[] d = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = i * <span class="number">2</span>;</span><br><span class="line">            d[i] = (<span class="keyword">byte</span>) (charToByte(hexChars[pos]) &lt;&lt; <span class="number">4</span> | charToByte(hexChars[pos + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convert char to byte</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c char</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">charToByte</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>) <span class="string">"0123456789ABCDEF"</span>.indexOf(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hex2Str</span><span class="params">(<span class="keyword">byte</span>[] raw)</span> </span>&#123;</span><br><span class="line">        String HEXES = <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line">        <span class="keyword">if</span> (raw == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder hex = <span class="keyword">new</span> StringBuilder(<span class="number">2</span> * raw.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">byte</span> b : raw) &#123;</span><br><span class="line">            hex.append(<span class="string">"0x"</span>);</span><br><span class="line">            hex.append(HEXES.charAt((b &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>))</span><br><span class="line">                    .append(HEXES.charAt((b &amp; <span class="number">0x0F</span>)));</span><br><span class="line">            hex.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hex.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到到main方法。主要就是解析一组电源打开的报文。其实没有什么东西，就是利用DataInputStream来读取。只是长度是变动的，所以我们需要先读出长度，然后根据长度再向后读出其它字段。</p><p>然后控制台就会输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">报文长度：17</span><br><span class="line">sn：1234567890123</span><br><span class="line">功能码：0x21 </span><br><span class="line">数据：0x01 </span><br><span class="line">校验：0x57 0x9D</span><br></pre></td></tr></table></figure></p><p>实际的业务情况会比这个复杂,所以最好做一些抽象和封装。不要像我文章里写的流水式编程。因为如果不封装后面维护会看起来很痛苦。还会有大量重复代码。不应该对每一组报文都重复的手写一次解析的过程。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>组装和解析字节报文其实是一项非常基础的能力。在java中已经有比较方便的DataInput类型套接字方便解析了。我们平时调试和开发的过程中尽量做到log日志，见行知意，并最好把hex格式转换成字符串来查看。一般出奇两头碰协议的时候容易引发bug。到后期稳定后基本上不用再碰。</p><p>再一个可能会有小伙伴疑惑为什么不直接用json来做透传。这个问题很早之前就讨论过，要尽量避免透传内容太大。用字节位来做字段会增加传播的效率和稳定性。学习本篇的内容后，其实还可以尝试去用字节的方式读取MP3、jpg、apk等文件中的头信息。也是一个好练手的办法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作调动。暂时停更了一段时间。续上一篇我们学习了如何去自定义一组报文，今天我们接着解析和组装报文。&lt;br&gt;前面我们讲过在物联网通信中实际上不论我们使用什么方式作为通信介质，其本质就是字节。所以我再一次对本章节的内容进行了调整，我们不讲Socket和ServerSocket这两个阻塞式IO Socket如何写。那个意义不大。&lt;br&gt;
    
    </summary>
    
    
      <category term="物联网" scheme="http://www.dajipai.cc/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Android与物联网设备通信-自定义报文与字节序</title>
    <link href="http://www.dajipai.cc/archives/dbd40ba8.html"/>
    <id>http://www.dajipai.cc/archives/dbd40ba8.html</id>
    <published>2018-06-18T16:20:37.000Z</published>
    <updated>2018-10-12T17:52:59.072Z</updated>
    
    <content type="html"><![CDATA[<p>前几节我们把网络通信中的基础都过了一遍，今天真正开始秀操作了。本节主要讲解如何在应用层上去定义报文的结构体。良好的报文设计会让今后的业务扩展变得轻松。顺带会讲解一下字节序。</p><a id="more"></a><p>可以发现最近的章节都把两个小节合并成了一个。这里最主要的原因是某些章节拟定标题的时候忘记注意篇幅考虑了，单独拆除了不合适，顾合并之，以后的文章如果还有这种需要合并的不再做额外说明哈，你们那么聪明看下标题肯定都懂的。o(∩_∩)o </p><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><ul><li><a href="http://www.dajipai.cc/archives/fe5f6231.html">Android与物联网设备通信-概念入门</a></li><li><a href="http://www.dajipai.cc/archives/f1d847c5.html">Android与物联网设备通信-数据传递的本质</a></li><li><a href="http://www.dajipai.cc/archives/dcba528a.html">Android与物联网设备通信-网络模型分层</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-UDP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-TCP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-基于TCP/IP自定义报文</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-什么是字节序</a></li><li><a href="http://www.dajipai.cc/archives/22074801.html">Android与物联网设备通信- 字节报文组装与解析</a></li><li><a href="http://www.dajipai.cc/archives/ead4653c.html">Android与物联网设备通信-利用UDP广播来做设备查找</a></li><li>Android与物联网设备通信-实现远程控制Android客户端</li><li>Android与物联网设备通信-Android做小型服务器</li><li>Android与物联网设备通信-调试技巧</li><li>Android与物联网设备通信-并行串行与队列</li><li>Android与物联网设备通信-数据安全</li><li>Android与物联网设备通信-心跳</li><li>Android与物联网设备通信-网络IO模型</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>自定义报文</li><li>字节序</li></ul><hr><h2 id="自定义报文"><a href="#自定义报文" class="headerlink" title="自定义报文"></a>自定义报文</h2><h3 id="什么是报文"><a href="#什么是报文" class="headerlink" title="什么是报文"></a>什么是报文</h3><p>实际上在前面几个章节中，我们已经针对网络模型中的各个报文做过分析。如果不出意外的话，你已经认识了它们。</p><p>比较形象的解释报文就像我们生活中随处可见的收纳盒。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-c241fe9b52f09de7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>它是用来装东西的。（废话！）</p><p>不同厂家生产的收纳盒，拥有不同尺寸的大小和容器空间。虽然他们都叫收纳盒（报文也一样）。但是可以存放的物件也不一样。</p><p>并且值得注意的是，一个收纳盒往往已经给你划分出了不同的区域，可以在他们的卡槽里放置符合槽位的物件。这一点和我们的报文也是惊人的一致。倘若你把一个不属于这个地方的东西强行塞入，就会弄坏它。在报文里把内容放置在错误的字段上也会引发灾难。</p><p>总结一句话，报文就是用来为特定业务而设计成存储内容的一种格式描述，正是有了它才能让发收数据有了参考，而不会搞乱。说到这里，你大概已经有完全明白了报文是什么东西了吧，那么我们开始定义一组报文。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p> 怎么定义呢？当然不是凭空去写。我们得先有业务嘛。</p><p> <strong>需求：</strong></p><p> 我们需要通过手机控制空调的<strong>开关、模式和温度</strong>。请设计一下手机该对空调说发送些什么，空调怎么去认识手机发过来的内容。</p><p> 遥控的逻辑图我偷个懒，就不画，大家自行脑补。</p><p> <img src="https://upload-images.jianshu.io/upload_images/1110736-84cbbaaaa958357f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/140" alt="image.png"></p><p> 什么，你脑子补不过来？</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-bc5d199adc8797ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><p> 就是你按下遥控器对着空调的那种场景呀。</p><p> <strong>字段分析：</strong></p><p> 这里的需求拆出来就三个功能：</p><ul><li><p><strong>开关：</strong> 属于<code>true</code>和<code>false</code>逻辑。</p></li><li><p><strong>模式：</strong> 有制冷、制热、自动、换气、除湿等。</p></li><li><p><strong>温度：</strong> 一个数值。</p></li></ul><p>通过对功能进行分析，这里说明我们这个报文上设计字段需要满足三种功能。并且每种功能对应里面的内容也是不一致的。有<code>真假</code>、<code>枚举</code>和<code>数值</code>，则对应的内容的长度也是不一致的。</p><p>好，我先给出我设计报文结构方案，一起来看一下。</p><p><strong>基本结构：</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-a997d4071b00fdf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><strong>长度：</strong> 描述整组报文从长度字段往后的字节数。</li><li><strong>设备号：</strong> 接受方序列号，用于确认是否是自己需要关系的包。</li><li><strong>功能码：</strong> 表示做什么事情的描述。比如这里的<code>开关、模式、温度</code></li><li><strong>内容：</strong> 功能码对应需要透传过去的内容。</li><li><strong>校验和：</strong> 确保数据的完整性和一致性。</li></ul><p>这里和我们第一节里介绍的结构体非常类似。我们接着往下看内容里的可变长如何使用。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-ff5a414f988f009b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上表给出了功能码对应的内容使用什么结构和长度，以最简单的<strong>开关</strong>为列。我们发送一组报文。在java里那么就会像下面这样去组装数据。</p><p>用java对象表示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCondBaseStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//长度</span></span><br><span class="line">    <span class="keyword">byte</span> sn[]; <span class="comment">//序列号</span></span><br><span class="line">    <span class="keyword">byte</span> code; <span class="comment">//功能码</span></span><br><span class="line">    <span class="keyword">byte</span> data[]; <span class="comment">//透传数据</span></span><br><span class="line">    <span class="keyword">byte</span> crc[]; <span class="comment">//校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>剩下的就是按照对应的功能，往这个对象里塞入数据。（偏底层的叫法是<code>结构体</code>）</p><p>最后发出去的数据就变成了这样：</p><p><strong>开关报文：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00 0x00 0x00 0x11 | 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33 | 0x21 | 0x01  |0x57 0x9D</span><br></pre></td></tr></table></figure><p>我们根据上面报文表手动解析一把16进制数据：</p><ul><li><p><strong>长度：</strong> <code>0x00 0x00 0x00 0x11</code>int类型站四个字节,这里0x11转换成十进制就是17。</p></li><li><p><strong>设备号：</strong> <code>0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33</code>占13个字节，转字符串后为：<code>1234567890123</code></p></li><li><p><strong>功能码：</strong><code>0x21</code>直接对应表中的<strong>开关</strong>功能。</p></li><li><p><strong>内容：</strong> <code>0x01</code> 直接对应表中的<strong>打开</strong>。</p></li><li><p><strong>校验和：</strong> <code>0x57 0x9D</code>验算和发送端一致则为数据正确。</p></li></ul><p>根据上面的解析说明长度为17，我们来算一下<code>设备号13字节+功能码1字节+内容1字节+校验和2字节</code>。正好长度等于17。</p><p>同样的道理如果把这里的功能码替换成温度调节，则导致长度发生变化。因为温度的内容结构是shot类型会占用两个字节。以此类推，其余的报文也是如法制炮。</p><p>这里给出其它两组报文，读者可以尝试自己动手解析一下试试，看能不能读出来其中的意思？</p><p><strong>模式报文：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00 0x00 0x00 0x11 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33 0x22 0x01 0x57 0x6D</span><br></pre></td></tr></table></figure><p><strong>温度调节报文：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00 0x00 0x00 0x12 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x31 0x32 0x33 0x23 0x00 0x1A 0x0D 0x95</span><br></pre></td></tr></table></figure><p>留个作业，想掌握这门技能的同学不妨可以尝试一下自己动手写一写组装报文转换成字节，再从字节转换回对象。在下一个章节我将放出这部分的解析代码。</p><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>从字面意思也能读出来是字节排列顺序。作为在上层开发应用的同学可能真的很少能实际接触使用到。因为一般都是使用大端口表示法。java默认也是大端表示法。以至于你甚至都是第一次听说还有这种东西？</p><p>我们先来看到底什么是字节序：</p><p>拿int来举例，我们知道一个int占用四个字节。那么四个字节在计算机按字节表现的形式是怎么排列的呢？</p><p>比如数字 <code>int a= 201806;</code>就会像下面这样</p><p><strong>小端口（little endian)</strong>表示法：<code>0x00 0x03 0x14 0x4E</code></p><p><strong>大端口（big endian）</strong>表示法：<code>0x4E 0x14 0x03 0x00</code></p><p>他们都表示数字201806，小端口就是低位字节在前高位字节在后。大端口则正好相反是高位在前低位在后。</p><p>从阮一峰老师博客里看到一张很形象的图。我贴一下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-23eae6bc746f14c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><p>解释一下为什么会出现两种不同的字节排列顺序。因为计算机并不知道单独一个字节代表具体的意思，它只会傻傻的读。计算机在设计的时候就采用了低位在前效率较高，但人们更加习惯高位在前的记法。所以就有了两种模式。</p><p>而物联网开发中有些硬件嵌入式开发会采用小端模式，而更上层应用开发者更倾向用大端模式，如果有一方没有对此转换处理就会造成数据老读出来是错的，而代码上看起来和协议实现一致的低级错误。</p><p>部分参考：<br><a href="http://www.ruanyifeng.com/blog/2016/11/byte-order.html" target="_blank" rel="noopener">理解字节序</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几节我们把网络通信中的基础都过了一遍，今天真正开始秀操作了。本节主要讲解如何在应用层上去定义报文的结构体。良好的报文设计会让今后的业务扩展变得轻松。顺带会讲解一下字节序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="物联网" scheme="http://www.dajipai.cc/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Android与物联网设备通信-UDP&amp;TCP协议</title>
    <link href="http://www.dajipai.cc/archives/d555ca34.html"/>
    <id>http://www.dajipai.cc/archives/d555ca34.html</id>
    <published>2018-06-12T05:00:37.000Z</published>
    <updated>2018-10-12T17:52:59.071Z</updated>
    
    <content type="html"><![CDATA[<p>有很多小伙伴私聊我说更新太慢，夺命吹吹吹。一周一次，还不能满足你们吗？</p><p>好，那我不写了。╭(╯^╰)╮！！！</p><p>额，尽量保持完成审核后就交货发布啦。实际上前面的章节都是周末完成等到周三才发的。</p><p>上一节我们细说了网络模型分层。知道了七层分法实际现在只有五层了。今天我们展开来学习传输层UDP和TCP的协议。因为这两个协议关联性比较大，且篇幅不高。故合并层一个小节学习。</p><a id="more"></a><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><ul><li><a href="http://www.dajipai.cc/archives/fe5f6231.html">Android与物联网设备通信-概念入门</a></li><li><a href="http://www.dajipai.cc/archives/f1d847c5.html">Android与物联网设备通信-数据传递的本质</a></li><li><a href="http://www.dajipai.cc/archives/dcba528a.html">Android与物联网设备通信-网络模型分层</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-UDP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-TCP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-基于TCP/IP自定义报文</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-什么是字节序</a></li><li><a href="http://www.dajipai.cc/archives/22074801.html">Android与物联网设备通信- 字节报文组装与解析</a></li><li><a href="http://www.dajipai.cc/archives/ead4653c.html">Android与物联网设备通信-利用UDP广播来做设备查找</a></li><li>Android与物联网设备通信-实现远程控制Android客户端</li><li>Android与物联网设备通信-Android做小型服务器</li><li>Android与物联网设备通信-调试技巧</li><li>Android与物联网设备通信-并行串行与队列</li><li>Android与物联网设备通信-数据安全</li><li>Android与物联网设备通信-心跳</li><li>Android与物联网设备通信-网络IO模型</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>UDP</li><li>TCP</li></ul><hr><h2 id="UDP-（User-Datagram-Protocol）"><a href="#UDP-（User-Datagram-Protocol）" class="headerlink" title="UDP （User Datagram Protocol）"></a>UDP （User Datagram Protocol）</h2><p>它是一种高速但数据不可靠的协议，为什么说它不可靠呢？是因为与之对应的TCP是非常可靠和稳定的。我们先看一下UDP的报文结构再讲解传递数据过程的原理。</p><h3 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h3><p><img src="https://upload-images.jianshu.io/upload_images/1110736-75324d19ff9037b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以看到很简单，没有什么东西需要特别说明的，根据前几节的知识就可以推断出来。UDP的效率高并非在报文上，而是它的传输机制就是只管往外发，对方能不能接收到（是否存在），并不关心。</p><p>你一定还记得网络不通的时候ping一下，这种小秀的骚操作的把？没有错它的底层就是依靠UDP协议直接实现的，ping的过程就是客户端组装UDP报文，和DNS服务器接收解析UDP并响应客户端的过程。当ping不通的时候就会出现超时，即DNS服务器不回复客户端。</p><p>所以UDP的传输可理解成来数据了，就不管三七二一就是一个走你，拜拜了您勒。也不去校验到底有没有收到。</p><p>正常情况下一条报文会被路由、交换机经过一层层转发，最后到该接收的位置。他们依靠上一节提到的数据链路层和网络层来寻找主机。UDP协议只关心端口。这种最典型的UDP称为<strong>单播UDP</strong>，除此之外还有<strong>组播</strong>和<strong>广播</strong>。关于组播和广播，我们后续的章节讲到做查找设备时会详细讲解，并做一个小demo。</p><h2 id="TCP（Transmission-Control-Protocol）"><a href="#TCP（Transmission-Control-Protocol）" class="headerlink" title="TCP（Transmission Control Protocol）"></a>TCP（Transmission Control Protocol）</h2><p>相对UDP来说TCP协议就要稳定很多了。同样我们先看报文结构，再学习传输原理。</p><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img src="https://upload-images.jianshu.io/upload_images/1110736-03866fa54fd863ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们重点看几个字段说明：</p><ul><li><p><strong>序号：</strong> 表示发送端当前包位于整组数据的第几个字节，也叫流水号。用于确保数据组的稳定性。</p></li><li><p><strong>ack号：</strong> 也叫确认号，表示接收方收到了多少个字节，表示期待下一组数据的字节序号。</p></li><li><p><strong>数据偏移：</strong> 一般不用，但是出现在TCP头里如果可选字段增加后，就要在数据偏移中指明偏移的位置，最多可以将20字节的头扩展到60个字节。</p></li><li><p><strong>控制位：</strong> 6个标志位<strong>URG  ACK  PSH  RST  SYN  FIN</strong>每一个表示一个控制功能，也就是告诉对方当前的包是做什么用的标识。</p></li><li><p><strong>窗口：</strong> 接收端告诉发送端自身的缓存大小的。避免过大的数据包导致接收端接受不过来而丢失数据。</p></li></ul><h4 id="控制位详解"><a href="#控制位详解" class="headerlink" title="控制位详解"></a>控制位详解</h4><ul><li><p><strong>URG：</strong> 紧急指针标志是否有效。</p></li><li><p><strong>ACK：</strong> 确认序号是否有效。</p></li><li><p><strong>PSH：</strong> 刷新缓存标志1有效，0忽略，要求把数据尽快给应用，而不要放在缓存里。（java里的flush方法）</p></li><li><p><strong>RST：</strong> 异常标志，表示强制断开连接，在异常的情况下。</p></li><li><p><strong>SYN：</strong> 连接过程同步序号标志。</p></li><li><p><strong>FIN：</strong> finish标志，用于释放连接1表示关闭连接。</p></li></ul><p>咋一看你会发现TCP的报文比UDP复杂了好多，一大堆东西。我的老伙计，别担心。那么底层的事情又不要你处理。你只需要知道它们在干嘛。并且值得说的是在Java上做socket编程时，你根本就感知不到底层字段的状态。到上层在处理数据的时候仅仅只有一个输入流和输出流了。这样极大的方便了应用层的简便开发。</p><h3 id="TCP协议分析"><a href="#TCP协议分析" class="headerlink" title="TCP协议分析"></a>TCP协议分析</h3><p>我们知道TCP是面向连接的，它严格的把控住了每一次传输的数据的稳定性。那么它是如何做到的呢？干巴巴的说太过于抽象，现在我们实际动手写一下代码(<code>kotlin</code>)搭配利刃<code>wireshark</code>分析一下。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> ss=  ServerSocket(<span class="number">22222</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> accept = ss.accept()</span><br><span class="line">        <span class="keyword">val</span> dataInputStream = DataInputStream(accept.getInputStream())</span><br><span class="line">        <span class="keyword">val</span> dataOutputStream = DataOutputStream(accept.getOutputStream())</span><br><span class="line">        <span class="keyword">val</span> s = dataInputStream.readUTF()</span><br><span class="line">        dataOutputStream.writeUTF(<span class="string">"hello Server"</span>)</span><br><span class="line">        dataInputStream.close()</span><br><span class="line">        dataOutputStream.close()</span><br><span class="line">        accept.close()</span><br><span class="line">        println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> socket = Socket(<span class="string">"192.168.0.5"</span>, <span class="number">22222</span>);</span><br><span class="line">    <span class="keyword">val</span> dataOutputStream = DataOutputStream(socket.getOutputStream())</span><br><span class="line">    <span class="keyword">val</span> dataInputStream = DataInputStream(socket.getInputStream())</span><br><span class="line">    dataOutputStream.writeUTF(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">val</span> s = dataInputStream.readUTF()</span><br><span class="line">    dataInputStream.close()</span><br><span class="line">    dataOutputStream.close()</span><br><span class="line">    socket.close()</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是wireshark无法直接抓到TCP在本地的回路包，但是我们可以使用命令行配置一下就可以了，不然抓不到本机的回路包。</p><ul><li><p>给路由表添加一条<br><code>route add 本机IP mask 255.255.255.255 路由IP metric 1</code></p></li><li><p>抓完删除<code>route delete 本机IP</code></p></li></ul><p>为了方便演示，我这里使用了两块网卡。所以往路由里添加了两次回路IP。</p><p>这里首先我们开启服务端，进入了循环监听状态，随后开启了客户端连接上后发送一个<code>hello</code>，服务端收到后回复了一个<code>hello Server</code>。再没有做更多的事情了。我们来看一下通过wireshark抓到的包。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-9a517cfaf40920a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>客户端： <code>192.168.0.4</code>端口：<code>55705</code>（操作系统协议栈分配）</li><li>服务端： <code>192.168.0.5</code> 端口：<code>22222</code>（我们定义的）</li></ul><p>1.启动服务端后，操作系统将开始对<code>22222</code>端口的<code>SYN</code>包进行监听。</p><p>2.客户端启动，并尝试连接服务端，由操作系统协议栈随机分配一个发送端口。</p><h4 id="握手"><a href="#握手" class="headerlink" title="握手:"></a>握手:</h4><p>3.客户端组装一组<code>SYN</code>报文发送至服务端<code>22222</code>号端，标记客户端<code>seq</code>为<code>0</code>。<strong>（完成第一次握手）</strong></p><p>4.服务端收到<code>SYN</code>包，并组装一组<code>SYN、ACK</code>报文，内容是告诉客户端我确认了你的<code>SYN</code>包，并期待你的下一组数据从<code>1</code>开始，标记服务端<code>seq</code>为<code>0</code>。<strong>（完成第二次握手）</strong></p><p>5.客户端收到服务端返回的<code>SYN、ACK</code>包报文，，标记客户端<code>seq</code>为<code>1</code>，并组装一组<code>ACK</code>报文，内容是告诉服务端期望收到的下一组<code>ack</code>从<code>1</code>开始。<strong>（完成第三次握手）</strong></p><h4 id="发包"><a href="#发包" class="headerlink" title="发包:"></a>发包:</h4><p>6.客户端组装了一组<code>PSH、ACK</code>包，并带上<code>ack=1</code>，内容为<code>hello</code>，发送个服务端。</p><p>7.服务端收到了内容为<code>hello</code>的包，确认后将<code>ack</code>加上收到的内容的长度。组装一组<code>PSH、ACK</code>并带上<code>ack=8</code>发送给客户端。</p><h4 id="挥手"><a href="#挥手" class="headerlink" title="挥手:"></a>挥手:</h4><p>8.客户端收到服务端的消息，更新自己的<code>seq=8</code>,并组装一组<code>FIN、ACK</code>包，并带上<code>ack=15</code>确认号，尝试请求断开连接。<strong>（客户端第一次主动挥手）</strong></p><p>9.服务端收到客户端的<code>FIN</code>包，更新自己的<code>seq=15</code>，并组装一组<code>FIN、ACK</code>包，并带上<code>ack=8</code>发送给客户端。<strong>（服务端确认，开始第二次挥手。）</strong></p><p>10.客户端收到服务端的<code>ack</code>包并检测<code>seq</code>是否一致，组装一组<code>ACK</code>包发送给服务端。<strong>（第三次挥手）</strong></p><p>11.服务端收到客户端的<code>ack</code>并检测<code>seq</code>是否一致,组装一组<code>ACK</code>包发送给客户端。<strong>（第四次挥手）</strong></p><p>上面描述的这个过程从字面上去看并没有太大意义，我希望你真正打开wireshark和代码，调试着玩玩。</p><h4 id="回顾过程："><a href="#回顾过程：" class="headerlink" title="回顾过程："></a>回顾过程：</h4><p><strong>握手：</strong> 客户端和服务端会先进行三次握手，握手的时候会告诉对方自身的窗体大小和ack确认号。这个过包的功能是从<code>ACK、SYN</code>来达到认识的。</p><p><strong>传输数据：</strong> 在接受对方的数据时，在下一组包里带上<code>ACK</code>标记告知对方我已经收到了多少内容，期待下一组内容的起始位置。</p><p><strong>挥手：</strong> 相互确认包是否发送完整，再双方确认了<code>ACK</code>后。才真正挥手完毕。</p><p><strong>丢包或包校验不对情况：</strong> 操作系统协议栈会根据<code>ACK</code>和<code>SEQ</code>号对控制位为<code>ACK</code>的包进行校验，如果对不上则要求重发上一组包。</p><hr><p>到此<code>UDP&amp;TCP</code>的协议我们就学习完了。这里没有去演示<code>UDP</code>包的抓取过程，因为如果<code>TCP</code>都会了<code>UDP</code>就不是什么难题。再一个没有展示<code>wireshark</code>的具体使用过程，因为网上实在有很多优秀的教程了。</p><p>即便如此，我敢打赌的是如果读者是第一次接触<code>TCP/IP</code>绝对会因为很多概念和发来发去的字段搞得头晕或者一知半解。因为我的能力还不足以让你看看文章就完全懂了。（原话出自凯哥 <code>^o^</code>）</p><p>听我一句劝，这个时候不要放弃，成热打铁赶快打开分析工具，照着我前面的代码跑起来。再拿出纸笔写写画一画。深挖一下真正的去感受它们的巧妙之处。你会感觉这个设计是非常棒的。</p><p>话说大家看得真的有收获吗？如果觉得不错，又想奖励我一下戳这里<a href="http://www.dajipai.cc/reward/">打赏</a>（听说打赏有吹更效果噢）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有很多小伙伴私聊我说更新太慢，夺命吹吹吹。一周一次，还不能满足你们吗？&lt;/p&gt;
&lt;p&gt;好，那我不写了。╭(╯^╰)╮！！！&lt;/p&gt;
&lt;p&gt;额，尽量保持完成审核后就交货发布啦。实际上前面的章节都是周末完成等到周三才发的。&lt;/p&gt;
&lt;p&gt;上一节我们细说了网络模型分层。知道了七层分法实际现在只有五层了。今天我们展开来学习传输层UDP和TCP的协议。因为这两个协议关联性比较大，且篇幅不高。故合并层一个小节学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="物联网" scheme="http://www.dajipai.cc/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Android与物联网设备通信-网络模型分层</title>
    <link href="http://www.dajipai.cc/archives/dcba528a.html"/>
    <id>http://www.dajipai.cc/archives/dcba528a.html</id>
    <published>2018-06-06T13:22:01.000Z</published>
    <updated>2018-10-12T17:52:59.072Z</updated>
    
    <content type="html"><![CDATA[<p>本来这个章节应该放在第二节的，更符合知识从整体往下看的逻辑。但是考虑到学习的过程是循序渐进的，我调整了一下。上一节，我们学习数据具体在传输中表现的形式。通过帧数据包裹一层层的上层数据达到传输的能力。今天我们来学习经典的网络模型分层。随着时间的推进变迁，有些层级结构已经被历史遗弃了。但是仍然需要知道有这么些东西。我们快来看吧。</p><a id="more"></a><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><ul><li><a href="http://www.dajipai.cc/archives/fe5f6231.html">Android与物联网设备通信-概念入门</a></li><li><a href="http://www.dajipai.cc/archives/f1d847c5.html">Android与物联网设备通信-数据传递的本质</a></li><li><a href="http://www.dajipai.cc/archives/dcba528a.html">Android与物联网设备通信-网络模型分层</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-UDP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-TCP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-基于TCP/IP自定义报文</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-什么是字节序</a></li><li><a href="http://www.dajipai.cc/archives/22074801.html">Android与物联网设备通信- 字节报文组装与解析</a></li><li><a href="http://www.dajipai.cc/archives/ead4653c.html">Android与物联网设备通信-利用UDP广播来做设备查找</a></li><li>Android与物联网设备通信-实现远程控制Android客户端</li><li>Android与物联网设备通信-Android做小型服务器</li><li>Android与物联网设备通信-调试技巧</li><li>Android与物联网设备通信-并行串行与队列</li><li>Android与物联网设备通信-数据安全</li><li>Android与物联网设备通信-心跳</li><li>Android与物联网设备通信-网络IO模型</li></ul><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>OSI模型结构</li><li>你该把焦点放在哪里</li></ul><hr><h2 id="OSI模型结构"><a href="#OSI模型结构" class="headerlink" title="OSI模型结构"></a>OSI模型结构</h2><p>网络模型分层结构又称OSI模型（Open System Interconnection Reference Model）。</p><p>我非常不想像往常你看到的文章一样，给你贴上来七层是哪几层。四层又是哪几层。枯燥无味，看完过两天又忘记。遵循知识是具有关联性来学习。熟悉的老司机们我们就当复习或者跳过好了。</p><p>从上往下七层结构分别是：</p><p><strong>应用层、表达层、会话层、传输层、网络层、数据链路层、物理层</strong></p><p>我们现在从底层至上来看看。每个层都在做什么事情。</p><h3 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h3><p><img src="https://upload-images.jianshu.io/upload_images/1110736-2e4fc12a7a2515ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p><p>还记得上一节讲到的<strong>数字信号</strong>么？它就是第一层<strong>物理层</strong>。</p><p>即：比特信号，在物理介质中传输。物理层上不关注任何上层协议和结构，对于该层而言就是任性的为所欲为往外输出和接受。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-33eba162cd193732.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><p>通俗来说就像现实世界中的马路一样，每条路都可以四通八达到枢纽，车就是比特信号。马路从来不管车子里坐的是宝马车上爱哭的她，还是摩托车上放DJ的你。</p><p>对应的物理层介质：<code>RJ-45 光钎 网卡 双绞线 以太网 调制解调器 电力线通信 同步光网络 光导纤维 同轴电缆  等</code></p><h3 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h3><p><img src="https://upload-images.jianshu.io/upload_images/1110736-81374cddf5fb415d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><p>数据链路层其实就是对我们上一节讲到的数据帧进行处理，它们表示数据桢内的消息发给谁，谁需要关心这一桢数据。对帧的收发顺序同步管理进行控制。由于我们的操作系统都是多进程多应用的，该层并不知道数据是来自哪个应用的，更不知道内容具体是什么，他们只负责把数据帧输入输出到对应的单元和把控帧数据质量。</p><p>记不清的同学请翻到上一节<strong>包数据MAC帧</strong>。</p><p>其中数据链路层又被划分成：<a href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">介质访问控制（MAC）子层</a>和<a href="https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%93%BE%E8%B7%AF%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">逻辑链路控制</a></p><p>对应：<code>ARP GPRS 以太网 WIFI  PPP PPPoE 等</code></p><h3 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层(Network Layer)"></a>网络层(Network Layer)</h3><p><img src="https://upload-images.jianshu.io/upload_images/1110736-35006247448dbea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><p>网络层的工作就是把对应的数据输送到对应目标的IP上去，和数据链路层相比很类似。但是数据链路层是针对相邻的硬件设备的MAC地址单元的。MAC地址太过于复杂和不好记。才产生了IP层协议，也就是现在我们说的OSI中的网络层。可以借助以太网IP协议将数据发送到以太网以内的任何设备上。与之相关联的是IP数据包报文，在上一节也有提到。</p><p>我们多少都有配置过IP的经历，这里的IP配置就和网络层有很大的关联。正式由于以太网的推进演变导致了这一层被抽象出来了。如果要把网络层内容完全讲清楚有些超纲，它依托了路由器、交换机、集线器等工作原理。这里不做硬性规定，可扩展学习。当然网络层不仅只有IP协议这一种。</p><p>对应：<code>IP（v4·v6） ICMP（v6） IGMP IS-IS IPsec BGP RIP OSPF RARP 等</code></p><h3 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h3><p><img src="https://upload-images.jianshu.io/upload_images/1110736-59c2f8b7df7380b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>传输层属于传输控制协议，比如TCP、UDP。它的存在是为了数据的稳定和可靠而设计的。因为更底层的的协议对于数据包体里本身的内容是不透明的，如果出现丢包和紊乱的情况是无法知道应用层的数据是否还正确的。所以就产生了传输层来把控。现在只要是一台联网的设备系统都会具有操作系统协议栈。</p><p>而协议栈就是来保障上层应用的套接字IP地址、进出端口、数据内存块、数据包切割、响应等待、丢包重发、组装、挂起切换等问题。可以说他负责了各个应用层丢下来的数据在什么时候处理，对应远程设备回复的包如何输送到当前操作系统上，再数据进行分拣到对应进程的套接字端口上。非常类似快递中转站的工作。</p><p>对应：<code>TCP UDP DCCP SCTP RSVP PPTP 等</code></p><h3 id="会话层（session-layer）已废用"><a href="#会话层（session-layer）已废用" class="headerlink" title="会话层（session layer）已废用"></a>会话层（session layer）已废用</h3><p>以前是用来做维护管理会话状态的。比如我们有多条数据，是一次性全部发过去，还是一条条发过去。这个层现在已经废弃不用了。原因是应用层一般已经做了类似的事情。</p><h3 id="表示层（presentation-layer）已废用"><a href="#表示层（presentation-layer）已废用" class="headerlink" title="表示层（presentation layer）已废用"></a>表示层（presentation layer）已废用</h3><p>上层数据可能在传输的过程中，因为不同的操作系统或特殊的需要被转换成了有利于传输、利于计算机处理、安全因素等。表示层这里的意义可以理解为翻译的工作。和会话层一样也被废弃了。</p><h3 id="应用层（application-layer）"><a href="#应用层（application-layer）" class="headerlink" title="应用层（application layer）"></a>应用层（application layer）</h3><p>应用层就是作为应用开发者真正经常要接触的。它代表着我们的应用自己定义的协议体结构和业务内容。像HTTP这种常见的应用层协议已经被广泛的应用在web和各种终端设备中使用了。它真正决定了一套体系的应用从一端到另一端是如何互相识别的。关于应用层我们在后续的自定义报文的章节里做详细的讲解。</p><p>对应：<code>HTTP DHCP DNS FTP IMAP4 IRC NNTP XMPP POP3 SIP SMTP SNMP SSH TELNET RPC RTCP RTP RTSP SDP SOAP 等自定义协议</code></p><h2 id="你该把焦点放在哪里"><a href="#你该把焦点放在哪里" class="headerlink" title="你该把焦点放在哪里"></a>你该把焦点放在哪里</h2><p>前面提及到了一共七层分法，实际上只有五层了。下面我来看看这五层分别对应到完整的报文里是什么。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-8ac98f9a4e890448.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>那么其实我们平时开发只需要关注到传输层和应用层。它和我们写的程序有真正的关联。决定了我们的程序是选用那种传输方式和数据结构。而网络层与链路层一般在物联网开发中属于和运维部署关系较大。比如无法正常上网了。在开发环境正常到了线上环境就不正常这种问题。如果是专门从事物联网方向开发的话，还是非常有必要了解它们之间的工作原理的。只是和上层的关联性没有那么强。</p><hr><p>网络模型分层是一个非常庞大的体系，因为要对其系统的解释就必须牵扯到各种设备的工作原理。我在写这节的时候也是一边翻资料看书参考才能总结出来的，有地方描述不对还请指出。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-cd63bd69668b7965.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>本篇文章不够深度，有些描述可能只是我理解了，并不能使你理解透彻。更深的了解需要我们一起看书学习和自我实践才行。这里我推荐<a href="https://item.jd.com/26222331708.html" target="_blank" rel="noopener">《网络是怎么样连接》</a>的一书给读者参考。当然这并不会影响我们后续的章节学习进度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来这个章节应该放在第二节的，更符合知识从整体往下看的逻辑。但是考虑到学习的过程是循序渐进的，我调整了一下。上一节，我们学习数据具体在传输中表现的形式。通过帧数据包裹一层层的上层数据达到传输的能力。今天我们来学习经典的网络模型分层。随着时间的推进变迁，有些层级结构已经被历史遗弃了。但是仍然需要知道有这么些东西。我们快来看吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="物联网" scheme="http://www.dajipai.cc/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Android与物联网设备通信-数据传递的本质</title>
    <link href="http://www.dajipai.cc/archives/f1d847c5.html"/>
    <id>http://www.dajipai.cc/archives/f1d847c5.html</id>
    <published>2018-05-30T13:01:22.000Z</published>
    <updated>2018-10-12T17:52:59.071Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们了解了一些基本通信机制。为了更系统全面的学习，今天我来看一数据到底在传输中是什么东西，又是怎么解析的。</p><a id="more"></a><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><ul><li><a href="http://www.dajipai.cc/archives/fe5f6231.html">Android与物联网设备通信-概念入门</a></li><li><a href="http://www.dajipai.cc/archives/f1d847c5.html">Android与物联网设备通信-数据传递的本质</a></li><li><a href="http://www.dajipai.cc/archives/dcba528a.html">Android与物联网设备通信-网络模型分层</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-UDP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-TCP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-基于TCP/IP自定义报文</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-什么是字节序</a></li><li><a href="http://www.dajipai.cc/archives/22074801.html">Android与物联网设备通信- 字节报文组装与解析</a></li><li><a href="http://www.dajipai.cc/archives/ead4653c.html">Android与物联网设备通信-利用UDP广播来做设备查找</a></li><li>Android与物联网设备通信-实现远程控制Android客户端</li><li>Android与物联网设备通信-Android做小型服务器</li><li>Android与物联网设备通信-调试技巧</li><li>Android与物联网设备通信-并行串行与队列</li><li>Android与物联网设备通信-数据安全</li><li>Android与物联网设备通信-心跳</li><li>Android与物联网设备通信-网络IO模型</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>数字信号</li><li>时钟信号</li><li>信号衰减和抗干扰</li><li>包数据MAC帧</li></ul><p>我们知道对于计算机来说，所有的数据都是二进制，非零即一。那么有没有想过在数据传输中电信号长什么样子呢？</p><p>就像这样的结构，组成所有的数据。</p><h3 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h3><p><img src="https://upload-images.jianshu.io/upload_images/1110736-2e4fc12a7a2515ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p><p>我们的数据由一块叫网卡的硬件把数据包转换成电信号，通过网线进行传输到另一端。<br>转换的过程就是<strong>电压和电流的输出变化</strong>。</p><h3 id="时钟信号"><a href="#时钟信号" class="headerlink" title="时钟信号"></a>时钟信号</h3><p><img src="https://upload-images.jianshu.io/upload_images/1110736-49174fa8f032579b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><p>接受端收到信号的时候会根据信号时钟去切割比特信号，因为当连续的<code>1111 0000 1111</code><br>这种情况下接收方就不知道有<strong>几个1，几个0</strong>。所以会根据时钟信号去切割。通俗的说这里的时钟信号就是<strong>间隔多少算一个比特</strong>。</p><h3 id="信号衰减和抗干扰"><a href="#信号衰减和抗干扰" class="headerlink" title="信号衰减和抗干扰"></a>信号衰减和抗干扰</h3><p><img src="https://upload-images.jianshu.io/upload_images/1110736-cc5fecb2cf6c6f72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><p>实际场景在电信号传播中会受干扰。现在我们熟悉的计算机网络环境一般是使用RJ-45接口。也就是网口来作为端口。任何在地球上存在的能量都会因为熵导致损失或丢失。那么一个正常的正方波信号在传输中就会变成弯弯扭扭的线条。这时伟大的人想出了很多办法来解决这个问题。</p><p>其中<strong>双绞线</strong>(网线)就是一种优秀的抑制噪声方案。尽可能的去抗干扰和减少熵丢失，就是两根线像麻花一样缠绕在一起可以抵消一部分干扰。深究更细的颗粒度需要读者自行学习。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-473b870808e14d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><h3 id="包数据MAC帧"><a href="#包数据MAC帧" class="headerlink" title="包数据MAC帧"></a>包数据MAC帧</h3><p>这里的包是指网络数据包，网络包是将电信号转换成一组数据后的最基本单位。它的基本结构是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-79e4eda5ede79701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><ul><li>包头：各种网络底层的控制信息</li><li>数据体：上层数据的一个载体。（网络模型章节详解）</li></ul><p>网络包是一层一层的关系，非常类似俄罗斯套娃的结构，一层层包裹着内部。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-c8500e6518052e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p><p>我们来看一个网络包中最外层的MAC帧结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-ea635b632b1d89d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024" alt="image.png"></p><p>上面图中的结构是802.3以太网帧的结构。我们生活中大部分802.3(有线)，802.11(WIFI无线)。其中一组帧允许传输1500个字节，即1500×8比特数据。MAC帧的标准有多种，和历史包袱，我们只关注现在最常用的就好了。</p><ul><li>前导码和帧开始符：作为帧数据的开始标记（防粘包用）。</li><li>报文头：接收方MAC地址、发送方MAC地址、802.1Q可选字段、以太网类型</li><li>负载：数据体，即上层协议的报文头和数据。（类似俄罗斯套娃）</li><li>沉余校验：32位的循环冗余校验码，用于验证帧数据是否被损坏。</li><li>帧间距：16个空字节，用于切割开下一组MAC帧数据，防止粘连。</li></ul><p>MAC帧的上层一般装的是IP头报文和数据体。其实IP报文和MAC报文有些类似，但是IP报文更加复杂。这是由于网络分层导致的结果。也正式因为这样才可以让每一层协议不关注上层协议在做什么事情，到达解耦的目的。</p><p>再往上一层是IP报文结构，感兴趣的读者可以点<a href="https://zh.wikipedia.org/wiki/IPv4" target="_blank" rel="noopener">这里</a>查看。整体来看我们的数据就是下面这样的，也就是我前面提到的俄罗斯套娃结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-59c2f8b7df7380b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><hr><p>这么底层的协议和我们开发一个物联网通信应用有什么关系。现在我可以告诉你，其实和写业务代码没有太大干系，因为我们是在应用层上做设计。很多时候是基于一些稳定的协议内去做消息透传。但是呢，由于这部分是很基础的核心内容。可以说做android应用层的同学很难真正要碰到要自己去解析它们，一旦碰到了问题，或者硬件工程师和我们沟通起来却不明白它们在说什么岂不是很尴尬？嗯哼</p><p>下一节我们继续学习网络模型分层，来领略一下每层结构的意义，会和本节的关联比较大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们了解了一些基本通信机制。为了更系统全面的学习，今天我来看一数据到底在传输中是什么东西，又是怎么解析的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="物联网" scheme="http://www.dajipai.cc/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Android与物联网设备通信-概念入门</title>
    <link href="http://www.dajipai.cc/archives/fe5f6231.html"/>
    <id>http://www.dajipai.cc/archives/fe5f6231.html</id>
    <published>2018-05-23T15:55:37.000Z</published>
    <updated>2018-10-12T17:52:59.072Z</updated>
    
    <content type="html"><![CDATA[<p>我准备了一个专题Android与物联网设备通信，分为十来个小节完成。泛指Android连接其它硬件设备建立通信。之前的博客比较零零散散，这算是一次小小的挑战。尽量在工作回家后和周末来完成。</p><p>面对陌生的事物，举步维艰只是表象。时间会教你的。 –大鸡排</p><a id="more"></a><h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><ul><li><a href="http://www.dajipai.cc/archives/fe5f6231.html">Android与物联网设备通信-概念入门</a></li><li><a href="http://www.dajipai.cc/archives/f1d847c5.html">Android与物联网设备通信-数据传递的本质</a></li><li><a href="http://www.dajipai.cc/archives/dcba528a.html">Android与物联网设备通信-网络模型分层</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-UDP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/d555ca34.html">Android与物联网设备通信-TCP协议原理</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-基于TCP/IP自定义报文</a></li><li><a href="http://www.dajipai.cc/archives/dbd40ba8.html">Android与物联网设备通信-什么是字节序</a></li><li><a href="http://www.dajipai.cc/archives/22074801.html">Android与物联网设备通信- 字节报文组装与解析</a></li><li><a href="http://www.dajipai.cc/archives/ead4653c.html">Android与物联网设备通信-利用UDP广播来做设备查找</a></li><li>Android与物联网设备通信-实现远程控制Android客户端</li><li>Android与物联网设备通信-Android做小型服务器</li><li>Android与物联网设备通信-调试技巧</li><li>Android与物联网设备通信-并行串行与队列</li><li>Android与物联网设备通信-数据安全</li><li>Android与物联网设备通信-心跳</li><li>Android与物联网设备通信-网络IO模型</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>基本概念</li><li>指令的本质</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>透过现象去看本质，Android终端与物联网设备开发就是：</p><p><strong>在某种可到通信的媒介下，使用一种可控的协议，使Android终端与硬件设备端交换数据。</strong></p><p>关键字：<strong>通信媒介、传输协议、交换数据。</strong></p><ul><li><p>物理层(真实媒介)：蓝牙、红外、声波、WiFi、网口、串口等</p></li><li><p>传输层协议：TCP UDP</p></li><li><p>应用层协议：ModBus、MQTT、私有协议等</p></li><li><p>交换数据（透传）：业务类数据交互（在协议体内）</p></li></ul><p>有点蒙圈不?先别管那些协议是什么通信媒介如何传输的，我们先放一边。慢慢来。现在你只需要记住有这么个东西。</p><h2 id="指令的本质"><a href="#指令的本质" class="headerlink" title="指令的本质"></a>指令的本质</h2><p>现在假设我们有一台android设备和一块独立的硬件。我们倾向于把做某件事、任务、命令当做一个包来从一端（Server）发送给另一端（Client）。</p><p>比如手机控制某个设备关闭屏幕：</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-070cf296cd783dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android设备发送命令：&#123;关闭屏幕&#125;</span><br><span class="line">客户端收到命令：&#123;关闭屏幕&#125;</span><br></pre></td></tr></table></figure><p>指令有些像是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-56d3d4a3394e8023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">功能码:</span><br><span class="line">0x01 //关闭屏幕</span><br><span class="line">0x02 //重启设备</span><br><span class="line">0x03 //打开热感应红外</span><br><span class="line">0x04 //关闭热感应红外</span><br></pre></td></tr></table></figure><p>上面这段0x1则表示关闭屏幕，如果服务端发送一条功能码为0x01的指令给设备，设备就会执行关闭屏幕动作。从接受指令到动作执行。</p><p>我们需要弄明白的是，为什么要这样设计，因为更多的时候是我们需要自己定义。</p><ul><li>1.<strong>报文头和尾</strong>在不稳定的传输中可以用来标识一段信息结束和开始。</li><li>2.<strong>长度</strong>字段则用来标识长度字段往后的内容整体长度。</li><li>3.<strong>校验</strong>可以用来验证数据的完整性。</li><li>4.<strong>功能码和数据</strong>用来完成工作定义业务。</li></ul><p>上面这次通信设备会完成以下几个步骤：</p><ul><li>1.把数据读干净，并校验数据的完整性。</li><li>2.按照定义好的格式去切割读取字段。</li><li>3.根具协议体内的功能完成相应的动作。</li><li>4.按照协议回复服务端表示执行完毕。</li></ul><p>这里只提到了功能码，真实的业务场景会比这个复杂一些。会带上更多的数据体。我们会再后面的章节展开讲，这里只做初步的认识。</p><p>一般来说我们和硬件进行交互要尽量保持通信的内容简短，包的内容越小越好。这样的话就可以减少和避免产生切割包、丢包重发的情况。因为媒介的环境是不可控的，比如声波、红外会收到干扰，造成数据丢失或外界干扰紊乱。</p><p>这样一来，我们对于硬件设备这种特殊的通信采用字节流的方式就会使包变得很小，比如<a href="https://wenku.baidu.com/view/45b4ec4fbcd126fff7050bad.html" target="_blank" rel="noopener">ModBus的协议</a>，简单来说就是发送的包命令，按照事先确定好的。切割成不同的段来作为识别。我们把这种东西叫做报文。通常会包含报文头、内容长度、内容、报文尾(校验)。</p><hr><p>好了，今天先讲这么多消化一下。我也是因为近两年的工作需要才真正接触到Android和物联网设备通信的。把自己学到的一些经验分享出来，网上少有看到较好的介绍。一路摸索的过程中踩了不少坑。我尽量保持采用通俗易懂又循序渐进的方式来完成后续的文章。</p><p>扯一个跟主题有关的东西，大多数Java或Android程序员因为没有接触过太低层的通信。有些概念一知半解，听说过但也没能实际用过。如果有读者恰巧看到我这篇文章，又正好是浅尝或者工作需要。建议买书从基础的网络通信原理看起。然后再投入到工作中使用。网上的资料零零散散成体系的不多，通信层面上的错误和坑如果没有一定的经验，一般难以排查到问题。切记</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我准备了一个专题Android与物联网设备通信，分为十来个小节完成。泛指Android连接其它硬件设备建立通信。之前的博客比较零零散散，这算是一次小小的挑战。尽量在工作回家后和周末来完成。&lt;/p&gt;
&lt;p&gt;面对陌生的事物，举步维艰只是表象。时间会教你的。 –大鸡排&lt;/p&gt;
    
    </summary>
    
    
      <category term="物联网" scheme="http://www.dajipai.cc/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>瞎扯-表达</title>
    <link href="http://www.dajipai.cc/archives/9f0b14d0.html"/>
    <id>http://www.dajipai.cc/archives/9f0b14d0.html</id>
    <published>2018-05-17T00:00:37.000Z</published>
    <updated>2018-10-12T17:52:59.084Z</updated>
    
    <content type="html"><![CDATA[<p>表达是人与人直接互相传递信号的一种行为。可以是一个眼神、手势、口述。不过更多的情况下我们指语言表述。</p><p>为什么今天要扯到表达这样一个主题，它太有用了。一个人的表达能力将决定他是否能够和其他人形成友好的关联。</p><p>牛人总是可以把复杂的道理和逻辑，清楚的描述出来。所以他们是牛人。而绕来绕去的说法只能说给同等聪明的人听。</p><a id="more"></a><p>我觉得不会表达也代表了缺乏换位思考的能力，这个说法不一定正确。但背后还是有一些逻辑存在。如果表达某事之前能够先想一想我这样说，对方能听懂吗？有时候这种细微的东西就是会影响到生活中的方方面面。</p><p>比如：要向公司技术内部群描述一个工程上的问题最后是如何解决的。我会选择先打开一个记事本，把要说明的事项排列出来。再把我要说的话一句句写清楚。最后读一读确认没有问题后粘贴到群里发送，相当于缓冲吧。（当然不是每次都这样）</p><p>而不是一句句的描述，说一句发一句，断断续续。不注意上下文，仅站在自己的角度在描述问题。这就会导致当信息被传递到其他人眼中时，看了半天感觉怎么就这么费解。</p><p>我们来看一下同样的一个问题，两种方式去表达。</p><p><strong>描述1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A:软件好像没问题。</span><br><span class="line"></span><br><span class="line">B:？？？</span><br><span class="line"></span><br><span class="line">A：上午说的那个断网没问题。</span><br><span class="line"></span><br><span class="line">B:你这边是好的吗？</span><br><span class="line"></span><br><span class="line">A：我跑了一遍都是正常的。</span><br><span class="line"></span><br><span class="line">B：那我现在怎么办？</span><br><span class="line"></span><br><span class="line">A：你看看路由信号。</span><br><span class="line"></span><br><span class="line">B：看了，然后？</span><br><span class="line"></span><br><span class="line">A：信号好吗？</span><br><span class="line"></span><br><span class="line">B：信号正常呀。</span><br><span class="line"></span><br><span class="line">A:那你再看看xxx</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p><strong>描述2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A:关于上午提到的长连接断断续续不稳定情况，技术组做了排查。我们自身的软件并没有异常。</span><br><span class="line">需要进一步确定以下几个问题，可能会导致不稳定。</span><br><span class="line"></span><br><span class="line">1.线上环境的路由和网关是否采用有线连接。</span><br><span class="line">2.路由中的4G信号是否稳定。</span><br><span class="line">3.存不存在现场有断电的情况。</span><br><span class="line"></span><br><span class="line">@xxx @xxx @xxx</span><br><span class="line"></span><br><span class="line">B:收到，我排查一下。</span><br></pre></td></tr></table></figure></p><p>描述1和2都在解决同一个问题，但是很明显可以看到第二种方式是经过了整理的。不仅排查了问题，同时提供了下一步的操作。即提前想到我能为对方多做一些什么事情，或提供更多的帮助。</p><p>这种事情在很多技术群里简直充斥着类似描述1这种表达方式，导致一个问题卡了好半天。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">A:APP直接闪退，救命呀，求助。</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">热心B:什么异常嘛？</span><br><span class="line"></span><br><span class="line">A:你等一下，我看看</span><br><span class="line"></span><br><span class="line">A:OutOfMemoryError，我知道啦。</span><br><span class="line"></span><br><span class="line">热心B：。。。。。</span><br><span class="line"></span><br><span class="line">暴躁C：你tm下断点呀，你看异常呀。什么都不看调试也不会，</span><br><span class="line">出问题就到群里吼，谁回答你一下，你就跟孙子一样跟着问。人家又不欠你的。</span><br><span class="line"></span><br><span class="line">A:我问问题怎么了。又不碍着你事。</span><br><span class="line"></span><br><span class="line">暴躁C：你搜索啊，百度 谷歌到处都可以找到好么。</span><br><span class="line"></span><br><span class="line">A:群里问不是更快嘛，搜的还要找。</span><br><span class="line"></span><br><span class="line">暴躁C：sb是无药可救的。</span><br><span class="line"></span><br><span class="line">A:你厉害，你牛。</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">半个小时后</span><br><span class="line"></span><br><span class="line">A:为什么Gradle编译老报错啊。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">暴躁C已退出群</span><br></pre></td></tr></table></figure><p>有的同学会觉得，鸡排你是不是闲的蛋疼。关注点都放在了这些上面。</p><p>我该如何回你好呢，带着笑或是很沉默？</p><p>对不起，这些年没有人能让我不寂寞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;表达是人与人直接互相传递信号的一种行为。可以是一个眼神、手势、口述。不过更多的情况下我们指语言表述。&lt;/p&gt;
&lt;p&gt;为什么今天要扯到表达这样一个主题，它太有用了。一个人的表达能力将决定他是否能够和其他人形成友好的关联。&lt;/p&gt;
&lt;p&gt;牛人总是可以把复杂的道理和逻辑，清楚的描述出来。所以他们是牛人。而绕来绕去的说法只能说给同等聪明的人听。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.dajipai.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>瞎扯-颠覆性</title>
    <link href="http://www.dajipai.cc/archives/dafeb1b8.html"/>
    <id>http://www.dajipai.cc/archives/dafeb1b8.html</id>
    <published>2018-05-13T03:05:37.000Z</published>
    <updated>2018-10-12T17:52:59.084Z</updated>
    
    <content type="html"><![CDATA[<p>哪怕是现在这个世界上已经是最好的东西，它也会有一天被新的东西取代。而且一般是猝不及防，也无法预知。</p><p>比如：</p><ul><li>难得的食物 –&gt; 泡面 –&gt; 饿了么、美团</li><li>马车 –&gt; 的士出租 –&gt; 滴滴、uber</li><li>竹简 –&gt; 报纸 –&gt; 今日头条、新浪微博</li><li>金子 –&gt; 纸币 –&gt; 支付宝、微信</li><li>排队等待 –&gt; 电话客服 –&gt;  Duplex等…</li><li>…</li></ul><a id="more"></a><hr><p>不难发现，在这些后起之秀没有出来之前，旧产物的圈内恐怕难以感知到未来。从高纬学术来说。我们三维生物缺少了对时间的维度掌控。也就不能看到未来。</p><p>而这些颠覆性的东西，目前来看无一不和互联网有关。就像无人车使司机行业落寞只是时间的问题。就像近两天的谷歌IO会上放出的Duplex替代客服的工作。</p><p>恐怕做客服的从业者，很难想象会有这么一天吧。未来会有更多的工作被取代。行业也是如此。</p><h2 id="冲击"><a href="#冲击" class="headerlink" title="冲击"></a>冲击</h2><p>拿客服举例，如果我们试图在这个行业通过不断的训练自己，让自己成为“嘴强王者”。厉害成神一样的客服。恐怕无法抵挡住洪水猛兽一般的AI了。那些苦练和勤奋就会变得毫无意义。</p><p>我现在在一家做客流统计硬件的公司，有一天我问同事。</p><p>说：你看我们现在的产品还能卖。而且卖得挺好的。会不会有一天出现压倒性的就被另一个行业给吞没了。</p><p>同事说：肯定的，我觉得这个和xxx有关系…..</p><p>面对新的维度，似乎我们很无能为力，就像是在鱼缸里的鱼，每天生活也挺滋润。吃吃食物，游游泳。但是水缸一旦破裂几乎无法进入下一个维度生存。</p><h2 id="淘汰"><a href="#淘汰" class="headerlink" title="淘汰"></a>淘汰</h2><p>我们可以大胆预的想一下，当大部分人的工作逐渐被AI或者新行业取代后。这里的大部分人又能去做什么呢？与其说进化论是筛选出优秀的基因，不如说是残酷的把一部分生物逼向死亡绝境。</p><h2 id="载体"><a href="#载体" class="headerlink" title="载体"></a>载体</h2><p>不难发现，上面那些颠覆了以前的产物公司，都存活在平台上。人最直观的看到的就是手机。手机也在被一次次刷新。很难在20年前想到今天的手机和当年的大哥大会有如此天差地别。</p><p>引出下一个载体在哪里呢？VR吗？或者还是其它更有趣更好的。微博漂浮在空气中。走到哪里都可以随时看到当前这一刻你站的位置在昨天、前天、去年…发生了什么。曾经谁来过，谁又说了什么话。他们不再是你的屏幕里，而直接暴露在你的裸眼之中亦或是脑海虚像。</p><p>电影《黑客帝国》中人类都装在了容器里，只活在意识流中。脱离现实世界存活。同样近两年大火的美剧《西部世界》同样接塑造了一个AI体验场。人类可以在内胡作非为，揭露人性的丑美和原始欲望。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哪怕是现在这个世界上已经是最好的东西，它也会有一天被新的东西取代。而且一般是猝不及防，也无法预知。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;难得的食物 –&amp;gt; 泡面 –&amp;gt; 饿了么、美团&lt;/li&gt;
&lt;li&gt;马车 –&amp;gt; 的士出租 –&amp;gt; 滴滴、uber&lt;/li&gt;
&lt;li&gt;竹简 –&amp;gt; 报纸 –&amp;gt; 今日头条、新浪微博&lt;/li&gt;
&lt;li&gt;金子 –&amp;gt; 纸币 –&amp;gt; 支付宝、微信&lt;/li&gt;
&lt;li&gt;排队等待 –&amp;gt; 电话客服 –&amp;gt;  Duplex等…&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.dajipai.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>瞎扯-学技术</title>
    <link href="http://www.dajipai.cc/archives/75c64cfc.html"/>
    <id>http://www.dajipai.cc/archives/75c64cfc.html</id>
    <published>2018-05-12T02:05:37.000Z</published>
    <updated>2018-10-12T17:52:59.084Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">学编程，做开发。你还能想起最开始为什么选择敲代码吗？</span><br><span class="line"></span><br><span class="line">混口饭吃？</span><br><span class="line"></span><br><span class="line">设计一个牛逼的玩意？</span><br><span class="line"></span><br><span class="line">解决这个世界上大多数你认为不完美的问题？</span><br><span class="line"></span><br><span class="line">又或者，仅仅是对技术的痴迷。</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h3 id="热情"><a href="#热情" class="headerlink" title="热情"></a>热情</h3><p>业务写久了会失去激情，进入职场的第一年。老大和我说。希望你一直保持这样的技术热情。</p><p>我问，为什么要这样说？难道前辈们不专研新技术吗？</p><p>….</p><p>这样一个问题，得到了许多无奈又现实的答案。渐渐明白。程序员在国内的环境被生活所迫，长期加班，忙家务各种琐事。年纪越大身边杂七杂八的事就越多。不是所有人都有很好的机遇进入到想要的生活状态，还是被生活强奸着。</p><p>年轻的程序员，总是可以快速灵活的学会更多的技能旁身。只是你愿不愿意把你的时间拿出来一部分作为学习。</p><p>为什么我们一次次无法逃脱被牵着鼻子走的命运。我们学这个那个，只是为了工作能更顺手，工资再高一点吗？（也许你正写着改变世界的代码，但绝大多数的工作并不是这样的。既小众，又枯燥无味。）</p><h2 id="危机"><a href="#危机" class="headerlink" title="危机"></a>危机</h2><p>公司业务扩张，最近在面试的过程中发现简历大概都是这样写的，熟悉RxJava、自定义View、设计模式…..</p><p>我不去评判这些，因为我还没有做过改变世界，让人眼前一亮的事情。所以多数人的选择即合理。</p><p>但问题是，当我问起来面试的开发者，你为什么要用RxJava的时候，他只是挝耳挠腮的僵持了半天说不出话。</p><p>当我再次追问是不是别人学了，你就跟着学？</p><p>答案：“是呀，大家都在用。”</p><p>我有些失望。</p><h2 id="太过"><a href="#太过" class="headerlink" title="太过"></a>太过</h2><p>关注技术本身没什么错。只是技术不是为了解决实际需求。似乎也失去了意义。我们可以爱学习，不可以为了学习而学习。</p><h2 id="卖药"><a href="#卖药" class="headerlink" title="卖药"></a>卖药</h2><p>这个世界就是这么巧被28原则分裂着，总有人跳出来制造恐慌和焦虑，然后兜售他们的经验。</p><p>这一点圈内有人说 和“微商”没什么区别。–原观点出处来自android大白的公众号。</p><p>我觉得也是。不过我更加喜欢称呼他们是卖药的人。而且有些喜欢搞教主情节，向教徒们疯狂洗脑，乐此不疲。我也关注这些公众号看文章。我想知道他们是如何去构造文章传播和写作手法。对于博主个人而言并没有什么坏处，反倒是锻炼了他自己。事情有两面性，作为大众的我们应当思考。</p><p>人就是这样的，做的每一件事、动作都是具有行为意识的。就是说背后都只少有一个点在支撑他在执行。否则不就是行尸走肉了？</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;学编程，做开发。你还能想起最开始为什么选择敲代码吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;混口饭吃？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设计一个牛逼的玩意？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解决这个世界上大多数你认为不完美的问题？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;又或者，仅仅是对技术的痴迷。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.dajipai.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>MAC下树莓派烧写Ubuntu+SSH</title>
    <link href="http://www.dajipai.cc/archives/c8a6696a.html"/>
    <id>http://www.dajipai.cc/archives/c8a6696a.html</id>
    <published>2018-05-10T15:05:22.000Z</published>
    <updated>2018-10-12T17:52:59.074Z</updated>
    
    <content type="html"><![CDATA[<p>今天抱出封印已久的树莓派重烧系统，下面的步骤记录了两件事供参考。这里略过了Linux下的基本操作以及vim编辑器的使用。如果你从未接触过。建议先学习一下基础知识。再来烧系统，否则会卡在某个地方浪费不必要的时间。不过既然都翻到了这篇博客，想必这些应该早就烂熟了。</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>烧写Ubuntu到树莓派</li><li>添加SSH服务</li></ul><h3 id="烧写Ubuntu到树莓派"><a href="#烧写Ubuntu到树莓派" class="headerlink" title="烧写Ubuntu到树莓派"></a>烧写Ubuntu到树莓派</h3><h5 id="1-下载-（注意解压成img格式）"><a href="#1-下载-（注意解压成img格式）" class="headerlink" title="1.下载 （注意解压成img格式）"></a>1.下载 （注意解压成img格式）</h5><p><a href="https://wiki.ubuntu.com/ARM/RaspberryPi#Download" target="_blank" rel="noopener">RaspberryPi-Download</a> -不带图形界面</p><p><a href="https://ubuntu-mate.org/download/" target="_blank" rel="noopener">ubuntu-mate-Download</a> -带图形界面</p><h5 id="2-格式化内存卡"><a href="#2-格式化内存卡" class="headerlink" title="2.格式化内存卡"></a>2.格式化内存卡</h5><p>使用<a href="https://www.sdcard.org/downloads/formatter_4/eula_mac/index.html" target="_blank" rel="noopener">SDFromatter工具</a>将SD卡格式化，傻瓜式操作。</p><h5 id="3-查看磁盘名称-（我这里是disk4）"><a href="#3-查看磁盘名称-（我这里是disk4）" class="headerlink" title="3.查看磁盘名称 （我这里是disk4）"></a>3.查看磁盘名称 （我这里是disk4）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diskutil list  </span><br><span class="line">df -h  (备选)</span><br></pre></td></tr></table></figure><h5 id="4-卸载这个磁盘"><a href="#4-卸载这个磁盘" class="headerlink" title="4.卸载这个磁盘"></a>4.卸载这个磁盘</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">diskutil unmountDisk /dev/disk4</span><br></pre></td></tr></table></figure><h5 id="5-写入设备"><a href="#5-写入设备" class="headerlink" title="5.写入设备"></a>5.写入设备</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo dd bs=4m if=ubuntu-16.04-preinstalled-server-armhf+raspi3.img of=/dev/rdisk4</span><br><span class="line"></span><br><span class="line">#输入上面这行命令即烧录，会假死一段时间，然后返回。此时如果你的读卡器上有灯的话会闪烁。</span><br><span class="line">563+0 records in</span><br><span class="line">563+0 records out</span><br><span class="line">2361393152 bytes transferred in 168.391249 secs (14023253 bytes/sec)</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 这条命令的最后的参数是rdisk4</p><ul><li><code>/dev/disk4s1</code> 表示分区</li><li><code>/dev/disk4</code> 表示块设备</li><li><code>/dev/rdisk4</code> 表示原始字符设备</li></ul><h5 id="6-再次卸载设备"><a href="#6-再次卸载设备" class="headerlink" title="6.再次卸载设备"></a>6.再次卸载设备</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo diskutil unmountDisk /dev/disk4</span><br></pre></td></tr></table></figure><h5 id="7-插卡开机"><a href="#7-插卡开机" class="headerlink" title="7.插卡开机"></a>7.插卡开机</h5><p>如果你使用的是不带图形界面版本的Ubuntu,那么一进入会有帐号密码需要登录。带界面的会让你自己设置无需担心。</p><p>默认帐号:</p><ul><li>登录名：<code>ubuntu</code></li><li>密码：<code>ubuntu</code></li></ul><p>root账户密码重置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd</span><br></pre></td></tr></table></figure><h3 id="添加SSH服务"><a href="#添加SSH服务" class="headerlink" title="添加SSH服务"></a>添加SSH服务</h3><h5 id="8-更新软件包"><a href="#8-更新软件包" class="headerlink" title="8.更新软件包"></a>8.更新软件包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h5 id="9-安装ssh"><a href="#9-安装ssh" class="headerlink" title="9.安装ssh"></a>9.安装ssh</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h5 id="10-修改sshd-config，增加密码登录"><a href="#10-修改sshd-config，增加密码登录" class="headerlink" title="10.修改sshd_config，增加密码登录"></a>10.修改sshd_config，增加密码登录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">#PermitRootLogin without-password 注释掉</span><br><span class="line"> PermitRootLogin yes # 添加</span><br></pre></td></tr></table></figure><hr><h5 id="11-ssh开启"><a href="#11-ssh开启" class="headerlink" title="11.ssh开启"></a>11.ssh开启</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh start 启动ssh</span><br><span class="line"></span><br><span class="line">sudo ps -e |grep ssh 有sshd,说明ssh服务已经启动</span><br></pre></td></tr></table></figure><h5 id="12-ssh开机自启动"><a href="#12-ssh开机自启动" class="headerlink" title="12.ssh开机自启动"></a>12.ssh开机自启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/rc.local</span><br><span class="line"></span><br><span class="line">service ssh start #添加启动</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天抱出封印已久的树莓派重烧系统，下面的步骤记录了两件事供参考。这里略过了Linux下的基本操作以及vim编辑器的使用。如果你从未接触过。建议先学习一下基础知识。再来烧系统，否则会卡在某个地方浪费不必要的时间。不过既然都翻到了这篇博客，想必这些应该早就烂熟了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="树莓派" scheme="http://www.dajipai.cc/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>你敢叫Android程序员找bug？不存在的这辈子都不会找bug</title>
    <link href="http://www.dajipai.cc/archives/52403d97.html"/>
    <id>http://www.dajipai.cc/archives/52403d97.html</id>
    <published>2018-04-30T17:05:37.000Z</published>
    <updated>2018-10-12T17:52:59.078Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">你 还在各种交叉闪烁而过的红色Log而感动痛苦不堪吗？</span><br><span class="line">你 还在熬夜加班修复那些散发着恶臭味的代码？</span><br><span class="line">你 还在寻找大佬帮你看一眼错误日志吗？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">据不完全随意统计，导致程序员加班的三大问题之一，八阿哥占据了程序员的职业生涯</span><br><span class="line">几乎一大半的时间，特别是前人挖得坑。(自己刨的就偷偷改了，趁还没有人发现)。</span><br></pre></td></tr></table></figure><p>现在开始，和找bug说拜拜。</p><a id="more"></a><h2 id="AutoEx"><a href="#AutoEx" class="headerlink" title="AutoEx"></a><a href="https://github.com/BolexLiu/AutoEx" target="_blank" rel="noopener">AutoEx</a></h2><p><img src="https://upload-images.jianshu.io/upload_images/5432543-1bef7d46ec75108e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720" alt=""></p><p>AutoEx采用全球领先的Stack Overflow技术。利用人工智障将别人踩过的bug和你的bug异常堆栈，通过大数据云计算返回符合你异常处理方案。这样可以为这个世界的Android猿省下大部分的偷懒时间。</p><p>旁白君：<code>程序员真的领先世界三十年，兄跌。这么强的吗？</code> </p><p><img src="https://upload-images.jianshu.io/upload_images/5432543-fc1de00b4807bfba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720" alt="image.png"></p><p>啊，真是太棒了，自从用了AutoEx。每天我都可以有更多的时间用来把自己当猪养了。</p><hr><p>他！ 她！ 它 ！。他们都在使用AutoEx来解决问题。你还在等什么？赶快打开全球最大的交友网站，依赖使用吧。</p><p>BGM响起：<code>因为我们是一家人 相亲相爱的一家人 有心才能体会 有心才会珍惜 ...</code></p><p>联系地址:<a href="https://github.com/BolexLiu/AutoEx" target="_blank" rel="noopener">AutoEx</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;你 还在各种交叉闪烁而过的红色Log而感动痛苦不堪吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你 还在熬夜加班修复那些散发着恶臭味的代码？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你 还在寻找大佬帮你看一眼错误日志吗？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;据不完全随意统计，导致程序员加班的三大问题之一，八阿哥占据了程序员的职业生涯&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;几乎一大半的时间，特别是前人挖得坑。(自己刨的就偷偷改了，趁还没有人发现)。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在开始，和找bug说拜拜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="异常" scheme="http://www.dajipai.cc/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Scroller原理作用分析</title>
    <link href="http://www.dajipai.cc/archives/d1346012.html"/>
    <id>http://www.dajipai.cc/archives/d1346012.html</id>
    <published>2018-03-15T10:22:10.000Z</published>
    <updated>2018-10-12T17:52:59.075Z</updated>
    
    <content type="html"><![CDATA[<p>本文同步自<a href="http://www.dajipai.cc/">我是一只香脆的大鸡排</a></p><h2 id="Scroller是什么？"><a href="#Scroller是什么？" class="headerlink" title="Scroller是什么？"></a>Scroller是什么？</h2><p>是一个帮助计算滑动偏移量的辅助类。关于滑动偏移的介绍可以参考上一篇文章。</p><a id="more"></a><h2 id="Scroller能给我们带来什么好处？"><a href="#Scroller能给我们带来什么好处？" class="headerlink" title="Scroller能给我们带来什么好处？"></a>Scroller能给我们带来什么好处？</h2><p>如下图所示，我们想把下面的圆从A点设置到B点。<br><img src="https://upload-images.jianshu.io/upload_images/1110736-791a68b575eb51bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们知道可以使用scrollTo与scrollBy来完成这个操作。但问题是直接调用会让人感觉唐突，就像下面这样的。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-faee3fae7921095b.gif?imageMogr2/auto-orient/strip" alt=""></p><p>那么Scroller就是解决这个问题的。如果学过flash的同学一定不会陌生。里面有个动画叫补间动画。这里的<strong>补间</strong>就是在变化前和变化后中间这个过程插入若干帧来实现一个平滑的变动。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-deb8a23b18816f6a.gif?imageMogr2/auto-orient/strip" alt=""></p><p>讲了，这么多。不如来看看到底怎么玩的。不贴源码，不搞一大坨文字说明。我画了一张简单的时序图来表示。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-6767469c42797d50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里我们可以看到Scroller本身并不对View进行操作，它仅仅提供了基本的配置，和计算工作。最后还是交给View本身去调用scrollTo和scrollBy方法来实现滑动。</p><h2 id="插值器"><a href="#插值器" class="headerlink" title="插值器"></a>插值器</h2><p>我们知道一组连续的动作，他们必定是一个个帧组合而成的。那么这些帧中的每一帧放多久，是匀速还是先加速后减速。来完成一组相对接近物理世界中的运动。在android中已经提供了一种叫<code>插值器的类</code>来计算这些。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-4f06bff3e4594dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>他们都实现了<code>Interpolator</code>接口。在<code>Scroller</code>的构造方法中如果我们不指定一个差值器，默认会使用<code>ViscousFluidInterpolator</code>。</p><p>具体代码实现见源码，避免代码占用文章篇幅。以后也是这样尽量保持只剖析原理和思路。避免被代码干扰了。</p><p>源码参考：<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/java/android/widget/Scroller.java" target="_blank" rel="noopener">Scroller.java</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文同步自&lt;a href=&quot;http://www.dajipai.cc/&quot;&gt;我是一只香脆的大鸡排&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Scroller是什么？&quot;&gt;&lt;a href=&quot;#Scroller是什么？&quot; class=&quot;headerlink&quot; title=&quot;Scroller是什么？&quot;&gt;&lt;/a&gt;Scroller是什么？&lt;/h2&gt;&lt;p&gt;是一个帮助计算滑动偏移量的辅助类。关于滑动偏移的介绍可以参考上一篇文章。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.dajipai.cc/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.dajipai.cc/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="View" scheme="http://www.dajipai.cc/tags/View/"/>
    
      <category term="滑动" scheme="http://www.dajipai.cc/tags/%E6%BB%91%E5%8A%A8/"/>
    
      <category term="Scroller" scheme="http://www.dajipai.cc/tags/Scroller/"/>
    
  </entry>
  
  <entry>
    <title>View的滑动视图理解</title>
    <link href="http://www.dajipai.cc/archives/39fa9566.html"/>
    <id>http://www.dajipai.cc/archives/39fa9566.html</id>
    <published>2018-03-14T09:16:00.000Z</published>
    <updated>2018-10-12T17:52:59.075Z</updated>
    
    <content type="html"><![CDATA[<p>本文同步自<a href="http://www.dajipai.cc/">我是一只香脆的大鸡排</a></p><p>刚入坑的时候，对于View滑动一直是一知半解的状态。其中工作多次遇见要用到了滑动时，满足需求草草了事就收场了。没有去深究内部原理。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-3e2c3fc8d50131f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><p>我们先来看一下基本使用和概念。</p><h3 id="scrollTo-int-x-int-y"><a href="#scrollTo-int-x-int-y" class="headerlink" title="scrollTo(int x, int y)"></a>scrollTo(int x, int y)</h3><p><code>滑动到某个点</code></p><h3 id="scrollBy-int-x-int-y"><a href="#scrollBy-int-x-int-y" class="headerlink" title="scrollBy(int x, int y)"></a>scrollBy(int x, int y)</h3><p><code>依照当前的坐标,偏移多少个单位</code></p><p>滑动都是相对而言的，android中的这两个方法是，父控件对于子控件起始坐标位置的一个描述点。将有父控件内部的mScrollX和mScrollY来记录。</p><h3 id="mScrollX"><a href="#mScrollX" class="headerlink" title="mScrollX"></a>mScrollX</h3><p><code>横坐标位置（向右）</code></p><h3 id="mScrollY"><a href="#mScrollY" class="headerlink" title="mScrollY"></a>mScrollY</h3><p><code>纵坐标位置（向下）</code></p><p>一般来说初始化这两个值都是零。在scrollTo方法和scrollBy被调用到的时候才会发生变化。</p><p>scrollBy最终还是利用了scrollTo来完成偏移。实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void scrollBy(int x, int y) &#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="偏移和坐标"><a href="#偏移和坐标" class="headerlink" title="偏移和坐标"></a>偏移和坐标</h3><p>这里的偏移和坐标就是指上面两个方法中的x和y值。如果有尝试使用过这两个方法的开发者可能会有一个疑惑，就是为什么这两个值是负数与现实世界正好相反的。why？？</p><p>下面我们解释一下这个问题。</p><p>比如下面这样：</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-517c90b46c59ea1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们需要把子控件沿x轴偏移160个单位，这样的话就会得到x:200,y:20。那么我们使用<code>scrollBy(-160,0)</code>方法来完成。疑惑也就在这里，按理来说我们使用偏移的值是从40~200。应该是增加160个单位，为什么要写成负的。</p><p>小伙伴可以试试传参数<code>(160,0)</code>，得到的结果就是子控件向左跑飞了，就像下面这样。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-01605c41ac684577.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>你想说，窝巢。为什么会介样！！</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-e2555bfa0c2a8c60.png?imageMogr2/auto-orient/strip%7CimageView2/2/h/150" alt=""></p><p>Android不听话，它不乖。</p><p>不不不，大哥哥你听我说。其实是这样的。我们可以把父控件的整个窗体想象成摄影机。我们假设子控件是我们场景里的静态物体，他们是不可移动的。当我们需要在屏幕上需要把子控件从左边的位置显示到右边的位置时。实际情况是摄影师把手中的摄像机应该是往左挪动。</p><p><img src="https://upload-images.jianshu.io/upload_images/1110736-388d629842f96e75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>想一想，没有错吧。揍是这样的。</p><p>还记得吗？初中物理说到的相对运动学。Android中的滑动视图也是基于这些理论的。这么看来我们前面的问题，传入的是<code>-160</code>也就能理解了，它是说父控件可见范围向左偏移。</p><h3 id="Padding-amp-Margin"><a href="#Padding-amp-Margin" class="headerlink" title="Padding&amp;Margin"></a>Padding&amp;Margin</h3><p>Padding&amp;Margin会不会对绘制区域造成影响，比如影响到mScrollX和mScrollY的值？</p><p>不会。子控件可视的范围起始点是在<code>父控件大小-父控件外边距-父控件内边距=的坐标</code>这个点就是就是滑动坐标的起始值起点，他们都为0。</p><h3 id="实验性学习技巧推荐"><a href="#实验性学习技巧推荐" class="headerlink" title="实验性学习技巧推荐"></a>实验性学习技巧推荐</h3><p>把手机上的开发者模式下打开以下两个功能</p><ul><li>1.显示触摸操作</li><li>2.显示布局边界</li></ul><p>新建一个项目，改变不同的滑动参数，然后运行起来看效果。八九不离十的分分钟学懂。感兴趣后再翻入进去看源码，不要停留在看博客和书籍的表面上。那样很快会忘记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> scrollX = frameLayout.getScrollX();</span><br><span class="line">            <span class="keyword">int</span> scrollY = frameLayout.getScrollY();</span><br><span class="line">            Log.d(SollActivity.class.getName(),String.format(<span class="string">"x:%s,y:%s"</span>,scrollX,scrollY));</span><br><span class="line">            frameLayout.scrollBy(-<span class="number">20</span>,<span class="number">0</span>);</span><br><span class="line">             scrollX = frameLayout.getScrollX();</span><br><span class="line">             scrollY = frameLayout.getScrollY();</span><br><span class="line">            Log.d(SollActivity.class.getName(),String.format(<span class="string">"x:%s,y:%s"</span>,scrollX,scrollY));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文同步自&lt;a href=&quot;http://www.dajipai.cc/&quot;&gt;我是一只香脆的大鸡排&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚入坑的时候，对于View滑动一直是一知半解的状态。其中工作多次遇见要用到了滑动时，满足需求草草了事就收场了。没有去深究内部原理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1110736-3e2c3fc8d50131f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.dajipai.cc/tags/Android/"/>
    
      <category term="源码分析" scheme="http://www.dajipai.cc/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="View" scheme="http://www.dajipai.cc/tags/View/"/>
    
      <category term="滑动" scheme="http://www.dajipai.cc/tags/%E6%BB%91%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用Termux，将Android当做Linux玩</title>
    <link href="http://www.dajipai.cc/archives/a748e934.html"/>
    <id>http://www.dajipai.cc/archives/a748e934.html</id>
    <published>2018-02-28T03:50:00.000Z</published>
    <updated>2018-10-12T17:52:59.078Z</updated>
    
    <content type="html"><![CDATA[<p>本文同步自<a href="http://www.dajipai.cc/">我是一只香脆的大鸡排</a></p><p><img src="https://termux.com/files/vim-main_framed.png" alt=""></p><blockquote><p>termux是一款android终端仿真器和Linux环境应用程序.</p></blockquote><p>通俗来说，你可以通过termux来把手机变成Linux终端/服务器。而且这一切不需要手机有没有root。</p><p>听着，termux跟其它那些shell终端妖艳贱货是不一样的。它是逼真的做到了Linux下才拥有的原汁功能。比如你想装一个Node.js、mysql、sqlmap、ssh、python、gcc….随心所欲吧。</p><a id="more"></a><p>使用起来也很简单，我们可以选择以下几种方式下载。</p><ul><li><a href="https://termux.com/" target="_blank" rel="noopener">https://termux.com/</a></li><li><a href="https://play.google.com/store/apps/details?id=com.termux" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.termux</a></li><li><a href="https://f-droid.org/packages/com.termux/" target="_blank" rel="noopener">https://f-droid.org/packages/com.termux/</a></li></ul><p>推荐使用F-Droid来安装。</p><h2 id="替换源"><a href="#替换源" class="headerlink" title="替换源"></a>替换源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export EDITOR=vi</span><br><span class="line">apt edit-sources</span><br></pre></td></tr></table></figure><p>替换或增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># The termux repository mirror from TUNA:</span><br><span class="line">deb [arch=all,arm] http://mirrors.tuna.tsinghua.edu.cn/termux stable main</span><br></pre></td></tr></table></figure></p><p>详细参考：</p><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/termux/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/termux/</a></p><h2 id="安装SSH"><a href="#安装SSH" class="headerlink" title="安装SSH"></a>安装SSH</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$apt install openssh//安装SSH端</span><br><span class="line">$sshd //启动</span><br><span class="line">$whoami //获取用户名</span><br></pre></td></tr></table></figure><p>在电脑终端输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p><p>会生成两个文件id_rsa（私钥）和id_rsa.pub（公钥），保存在~/.ssh/下。</p><p>利用adb push把公钥传到设备上去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push id_rsa.pub /sdcard/</span><br></pre></td></tr></table></figure></p><p>然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sdcard/id_rsa.pub  &gt;&gt; /data/data/com.termux/files/home/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><p>电脑ssh访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@192.168.0.158 -p 8022 //8022为默认端口</span><br></pre></td></tr></table></figure></p><h2 id="SSH端口增加修改"><a href="#SSH端口增加修改" class="headerlink" title="SSH端口增加修改"></a>SSH端口增加修改</h2><ul><li>vi /etc/ssh/sshd_config</li><li>添加 Port 8823</li><li>重启sshd </li></ul><h2 id="oh-my-zsh安装"><a href="#oh-my-zsh安装" class="headerlink" title="oh-my-zsh安装"></a>oh-my-zsh安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ apt install git</span><br><span class="line">$ apt install zsh</span><br><span class="line">$ git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">$ cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br><span class="line">$ chsh zsh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文同步自&lt;a href=&quot;http://www.dajipai.cc/&quot;&gt;我是一只香脆的大鸡排&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://termux.com/files/vim-main_framed.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;termux是一款android终端仿真器和Linux环境应用程序.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗来说，你可以通过termux来把手机变成Linux终端/服务器。而且这一切不需要手机有没有root。&lt;/p&gt;
&lt;p&gt;听着，termux跟其它那些shell终端妖艳贱货是不一样的。它是逼真的做到了Linux下才拥有的原汁功能。比如你想装一个Node.js、mysql、sqlmap、ssh、python、gcc….随心所欲吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.dajipai.cc/tags/Android/"/>
    
      <category term="Shell" scheme="http://www.dajipai.cc/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>感谢被教育了</title>
    <link href="http://www.dajipai.cc/archives/95d21ebb.html"/>
    <id>http://www.dajipai.cc/archives/95d21ebb.html</id>
    <published>2018-02-25T15:50:00.000Z</published>
    <updated>2018-10-12T17:52:59.081Z</updated>
    
    <content type="html"><![CDATA[<p>为什么说该被感谢被教育了呢？</p><p>我们总能遇见陌生的领域知识和一些你搞错的事情，当你被人突然揭穿或者戳中时。我不知道其他人的感受是如何的。至少我当下那一刻，内心是有些不适的。特别是当众被正确一方纠正时。我暂且把这种场景叫做“事物失控”。</p><p>而且我发现很多人身上能产生的不愉快都和“事物失控”有着很大的关系。我举几个列子：</p><ul><li>产品经理又改了一次需求，导致你不得已要重新捣鼓代码</li><li>你的小女朋友和别的男人去约会，而你还在家里学新技术？</li><li>心爱的手机被偷了，内存卡里有大量不可描述的照片！！！</li><li>胆小的你，被主持人叫上舞台当众发言</li><li>因为加班，没赶上最后一班地铁、公交也没有了</li><li>新娘结婚了，可新郎却不是你</li><li>····<a id="more"></a>没有错吧？这样看来，好像生活中所有的不愉快都可以归结到“事物失控”上。那在被教育的时候我多半也会产生这种情绪。我们应该学会去适应这些，才会使你变得更好。不是拽着个脸表示不满。</li></ul><p>过年前半个月，天色已晚，公司里还是灯火通明。我们都在加班加点的组装硬件和调试系统。因为第二天就要去线下部署环境了。在这之前需要把所有的流程全部过完。中间遇见了一个问题，在设备的静态网络配置中，出现了请输入<code>网络前缀长度：</code>这样一个填空。上面写着一排提示默认一般填写24。让我很费解的事情是为什么是24呢？然后我担心第二天要去线下的环境会因此弄错，或者不清楚这里填什么导致无法上网。特地把这两个同事叫了过来说：“这里有一个坑，明天一定要记得这里填写的就是24。”</p><p>懂网络的同事，过来看了一眼，扭头就走了，当场边走边大声的告诉我说：“哎呀，这不就是子网掩码的长度嘛！你看啊，ip四段，都是255。二进制下全是1，一共32个比特….一看你就没有学好网络的人。”当场我内心咯噔一下，感觉被当众教育了。也就是我前面提到的“事物失控”。连忙跟着说：“噢噢噢噢，懂了。懂了。”来掩盖当时的尴尬气氛，其实我还没有反应过来同事描述的原理，本能的把注意力放在了“一看你就没有学好网络的人”这句话上面。</p><p>问题也就在这里，多数时候。我们的真理被推翻时，动摇了之前的东西。以及对方说出的言论可能使你产生不适。你就会丢掉对方说的关于事实的一部分，更加关注到了不该关注的部分。那样子是不对的，尽管对方的言论确实造成了我们的不舒服。但我们一定会回忆起来，我当时哪里弄错了，他说的又是什么意思呢？而我当天晚上试图再一次弄清楚去查资料看子网掩码为什么是24这个问题时，根本无法看懂那些资料在描述什么事情。因为我已经被“事物失控”带来的坏处给害了。即便是如此简单的东西，我也无法静下心来读懂它。</p><p>直到今天晚上我系统的阅读《网络是怎样连接的》一书时，发现这个问题书上有讲，并且很简单的说清楚了。此时终于恍然大悟，原来那天只不过是我无法静下心来看资料，所以看不懂。这样的经历使得我对子网掩码的印象非常深刻。我敢打赌，在上学的时候老师绝对有教过，只是我并没有深刻的理解它。同样也要感谢同事能够当面给我说这件事，否则一般的场景下，倘若他只是说：“哦，24呀，记住啦！”。那么恐怕我将不知道什么时候才能真正明白呢！</p><p>这篇的题目我取的是《感谢被教育了》，与“事物失控”这个观点比较起来有些跑题，但我觉得正是因为这件事导致我得到这些的。所以我还是用了这个标题，我确实也被教育了，你别说，还挺爽的。</p><p>被教育是一件好事，不是坏事。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么说该被感谢被教育了呢？&lt;/p&gt;
&lt;p&gt;我们总能遇见陌生的领域知识和一些你搞错的事情，当你被人突然揭穿或者戳中时。我不知道其他人的感受是如何的。至少我当下那一刻，内心是有些不适的。特别是当众被正确一方纠正时。我暂且把这种场景叫做“事物失控”。&lt;/p&gt;
&lt;p&gt;而且我发现很多人身上能产生的不愉快都和“事物失控”有着很大的关系。我举几个列子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产品经理又改了一次需求，导致你不得已要重新捣鼓代码&lt;/li&gt;
&lt;li&gt;你的小女朋友和别的男人去约会，而你还在家里学新技术？&lt;/li&gt;
&lt;li&gt;心爱的手机被偷了，内存卡里有大量不可描述的照片！！！&lt;/li&gt;
&lt;li&gt;胆小的你，被主持人叫上舞台当众发言&lt;/li&gt;
&lt;li&gt;因为加班，没赶上最后一班地铁、公交也没有了&lt;/li&gt;
&lt;li&gt;新娘结婚了，可新郎却不是你&lt;/li&gt;
&lt;li&gt;····
    
    </summary>
    
    
      <category term="随笔" scheme="http://www.dajipai.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
